<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/engine/portal/engine/strings/hash/compile_time/compile_time_md5.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/portal/engine/strings/hash/compile_time/compile_time_md5.hpp" />
              <option name="originalContent" value="/**&#10;* Taken from:&#10; * https://github.com/abbbaf/Compile-time-hash-functions&#10; * Licensed under the MIT License Copyright (c) 2021 Assaf Levi.&#10; */&#10;&#10;&#10;#ifndef COMPILE_TIME_MD5_H&#10;#define COMPILE_TIME_MD5_H&#10;&#10;#include &quot;crypto_hash.hpp&quot;&#10;&#10;template &lt;typename H=const char*&gt;&#10;class CT_MD5 : public CryptoHash&lt;4&gt;&#10;{&#10;private:&#10;    // clang-format off&#10;    constexpr static int s[] = { 7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22, 5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20, 4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23, 6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 };&#10;    constexpr static uint32_t k[] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee , 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 , 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be , 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 , 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa , 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 , 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed , 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a , 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c , 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 , 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 , 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 , 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 , 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 , 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 , 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };&#10;    constexpr static int g_array[4][2] = { {1, 0}, {5, 1}, {3, 5}, {7, 0} };&#10;    // clang-format on&#10;&#10;&#10;    using Hash_T = CT_MD5&lt;H&gt;;&#10;    using PaddedValue_T = PaddedValue&lt;H&gt;;&#10;&#10;    struct hash_parameters&#10;    {&#10;        const Array&lt;uint32_t, 4&gt; arr;&#10;        const uint32_t f_array[4][5];&#10;&#10;        template &lt;typename... Args&gt;&#10;        constexpr hash_parameters(Args... args):&#10;            arr{args...},&#10;            f_array{{arr[3], 0, arr[2], arr[1], arr[3]},&#10;                    {arr[2], 0, arr[1], arr[3], arr[2]},&#10;                    {arr[3], 0, arr[2], 0xffffffff, arr[1]},&#10;                    {~arr[3], arr[1], 0, 0xffffffff, arr[2]}} {}&#10;&#10;        constexpr hash_parameters() :&#10;            hash_parameters(&#10;                (uint32_t)0x67452301,&#10;                (uint32_t)0xefcdab89,&#10;                (uint32_t)0x98badcfe,&#10;                (uint32_t)0x10325476&#10;                ) {}&#10;&#10;        constexpr uint32_t operator [](int index) { return arr[index]; }&#10;    };&#10;&#10;    constexpr Array&lt;uint32_t, 4&gt; create_hash(PaddedValue_T value, hash_parameters h, int block_index = 0)&#10;    {&#10;        return block_index * 64 == value.total_size&#10;            ? Array&lt;uint32_t, 4&gt;{&#10;                endianess_convertion(h[0]),&#10;                endianess_convertion(h[1]),&#10;                endianess_convertion(h[2]),&#10;                endianess_convertion(h[3])}&#10;            : create_hash(value, hash_block(value, h, h, block_index), block_index + 1);&#10;&#10;    }&#10;&#10;    constexpr uint32_t f_expr(int i, struct hash_parameters h) const&#10;    {&#10;        return ((h.f_array[i][0] | h.f_array[i][1]) ^ h.f_array[i][2]) &amp; h.f_array[i][3] ^ h.f_array[i][4];&#10;    }&#10;&#10;    constexpr uint32_t f(PaddedValue_T value, int block_index, int i, struct hash_parameters h) const&#10;    {&#10;        return f_expr(i / 16, h) + h[0] + k[i] + value[block_index * 16 + g(i)];&#10;    }&#10;&#10;    constexpr int g(int i) const&#10;    {&#10;        return (g_array[i / 16][0] * i + g_array[i / 16][1]) &amp; 0xf;&#10;    }&#10;&#10;    constexpr hash_parameters hash_block(&#10;        PaddedValue_T value,&#10;        struct hash_parameters h,&#10;        struct hash_parameters prev_h,&#10;        int block_index,&#10;        int i = 0&#10;        ) const&#10;    {&#10;        return i == 64&#10;            ? (struct hash_parameters){prev_h[0] + h[0], prev_h[1] + h[1], prev_h[2] + h[2], prev_h[3] + h[3]}&#10;            : hash_block(&#10;                value,&#10;                {&#10;                    h[3],&#10;                    h[1] + leftrotate(f(value, block_index, i, h), s[i]),&#10;                    h[1],&#10;                    h[2]&#10;                },&#10;                prev_h,&#10;                block_index,&#10;                i + 1&#10;                );&#10;    }&#10;&#10;public:&#10;    constexpr CT_MD5(H input) :&#10;        CryptoHash&lt;4&gt;(create_hash(PaddedValue_T(input, false), {})) {}&#10;&#10;};&#10;&#10;&#10;template &lt;typename T&gt;&#10;constexpr int CT_MD5&lt;T&gt;::g_array[4][2];&#10;template &lt;typename T&gt;&#10;constexpr int CT_MD5&lt;T&gt;::s[64];&#10;template &lt;typename T&gt;&#10;constexpr uint32_t CT_MD5&lt;T&gt;::k[64];&#10;&#10;&#10;#endif&#10;" />
              <option name="updatedContent" value="/**&#10;* Taken from:&#10; * https://github.com/abbbaf/Compile-time-hash-functions&#10; * Licensed under the MIT License Copyright (c) 2021 Assaf Levi.&#10; */&#10;&#10;&#10;#ifndef COMPILE_TIME_MD5_H&#10;#define COMPILE_TIME_MD5_H&#10;&#10;#include &quot;crypto_hash.hpp&quot;&#10;&#10;template &lt;typename H=const char*&gt;&#10;class CT_MD5 : public CryptoHash&lt;4&gt;&#10;{&#10;private:&#10;    // clang-format off&#10;    constexpr static int s[] = { 7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22, 5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20, 4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23, 6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21 };&#10;    constexpr static uint32_t k[] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee , 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 , 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be , 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 , 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa , 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 , 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed , 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a , 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c , 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 , 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 , 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 , 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 , 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 , 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 , 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };&#10;    constexpr static int g_array[4][2] = { {1, 0}, {5, 1}, {3, 5}, {7, 0} };&#10;    // clang-format on&#10;&#10;&#10;    using Hash_T = CT_MD5&lt;H&gt;;&#10;    using PaddedValue_T = PaddedValue&lt;H&gt;;&#10;&#10;    struct hash_parameters&#10;    {&#10;        const Array&lt;uint32_t, 4&gt; arr;&#10;        const uint32_t f_array[4][5];&#10;&#10;        template &lt;typename... Args&gt;&#10;        constexpr hash_parameters(Args... args):&#10;            arr{args...},&#10;            f_array{{arr[3], 0, arr[2], arr[1], arr[3]},&#10;                    {arr[2], 0, arr[1], arr[3], arr[2]},&#10;                    {arr[3], 0, arr[2], 0xffffffff, arr[1]},&#10;                    {~arr[3], arr[1], 0, 0xffffffff, arr[2]}} {}&#10;&#10;        constexpr hash_parameters() :&#10;            hash_parameters(&#10;                (uint32_t)0x67452301,&#10;                (uint32_t)0xefcdab89,&#10;                (uint32_t)0x98badcfe,&#10;                (uint32_t)0x10325476&#10;                ) {}&#10;&#10;        constexpr uint32_t operator [](int index) { return arr[index]; }&#10;    };&#10;&#10;    constexpr Array&lt;uint32_t, 4&gt; create_hash(PaddedValue_T value, hash_parameters h, int block_index = 0)&#10;    {&#10;        if (block_index * 64 == value.total_size) {&#10;            return Array&lt;uint32_t, 4&gt;{&#10;                endianess_convertion(h[0]),&#10;                endianess_convertion(h[1]),&#10;                endianess_convertion(h[2]),&#10;                endianess_convertion(h[3])};&#10;        } else {&#10;            return create_hash(value, hash_block(value, h, h, block_index), block_index + 1);&#10;        }&#10;    }&#10;&#10;    constexpr uint32_t f_expr(int i, struct hash_parameters h) const&#10;    {&#10;        return ((h.f_array[i][0] | h.f_array[i][1]) ^ h.f_array[i][2]) &amp; h.f_array[i][3] ^ h.f_array[i][4];&#10;    }&#10;&#10;    constexpr uint32_t f(PaddedValue_T value, int block_index, int i, struct hash_parameters h) const&#10;    {&#10;        return f_expr(i / 16, h) + h[0] + k[i] + value[block_index * 16 + g(i)];&#10;    }&#10;&#10;    constexpr int g(int i) const&#10;    {&#10;        return (g_array[i / 16][0] * i + g_array[i / 16][1]) &amp; 0xf;&#10;    }&#10;&#10;    constexpr hash_parameters hash_block(&#10;        PaddedValue_T value,&#10;        struct hash_parameters h,&#10;        struct hash_parameters prev_h,&#10;        int block_index,&#10;        int i = 0&#10;        ) const&#10;    {&#10;        if (i == 64) {&#10;            return hash_parameters{prev_h[0] + h[0], prev_h[1] + h[1], prev_h[2] + h[2], prev_h[3] + h[3]};&#10;        } else {&#10;            return hash_block(&#10;                value,&#10;                hash_parameters{&#10;                    h[3],&#10;                    h[1] + leftrotate(f(value, block_index, i, h), s[i]),&#10;                    h[1],&#10;                    h[2]&#10;                },&#10;                prev_h,&#10;                block_index,&#10;                i + 1&#10;                );&#10;        }&#10;    }&#10;&#10;public:&#10;    constexpr CT_MD5(H input) :&#10;        CryptoHash&lt;4&gt;(create_hash(PaddedValue_T(input, false), {})) {}&#10;&#10;};&#10;&#10;&#10;template &lt;typename T&gt;&#10;constexpr int CT_MD5&lt;T&gt;::g_array[4][2];&#10;template &lt;typename T&gt;&#10;constexpr int CT_MD5&lt;T&gt;::s[64];&#10;template &lt;typename T&gt;&#10;constexpr uint32_t CT_MD5&lt;T&gt;::k[64];&#10;&#10;&#10;#endif&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/portal/engine/strings/hash/compile_time/crypto_hash.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/portal/engine/strings/hash/compile_time/crypto_hash.hpp" />
              <option name="originalContent" value="/**&#10;* Taken from:&#10; * https://github.com/abbbaf/Compile-time-hash-functions&#10; * Licensed under the MIT License Copyright (c) 2021 Assaf Levi.&#10; */&#10;&#10;&#10;#ifndef CRYPTO_HASH_H&#10;#define CRYPTO_HASH_H&#10;&#10;#include &lt;iomanip&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iostream&gt;&#10;&#10;#include &quot;array.hpp&quot;&#10;#include &quot;utils.hpp&quot;&#10;&#10;#include &quot;circular_queue.hpp&quot;&#10;#include &quot;padded_value.hpp&quot;&#10;#include &quot;section.hpp&quot;&#10;&#10;//HASH_SIZE = (hash size in bits)/32&#10;&#10;template &lt;int HASH_SIZE&gt;&#10;class CryptoHash&#10;{&#10;&#10;private:&#10;    const Array&lt;uint32_t, HASH_SIZE&gt; hashed_value;&#10;&#10;protected:&#10;    constexpr CryptoHash(Array&lt;uint32_t, HASH_SIZE&gt; _hashed_value) :&#10;        hashed_value(_hashed_value) {}&#10;&#10;public:&#10;    bool operator ==(const CryptoHash&lt;HASH_SIZE&gt;&amp; second_hash) const&#10;    {&#10;        for (int i = 0; i &lt; HASH_SIZE; i++)&#10;        {&#10;            if (hashed_value[i] != second_hash.hashed_value[i])&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;    bool operator !=(const CryptoHash&lt;HASH_SIZE&gt;&amp; second_hash) const&#10;    {&#10;        return !(*this == second_hash);&#10;    }&#10;&#10;    uint32_t operator [](int index)&#10;    {&#10;        return hashed_value[index];&#10;    }&#10;&#10;&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CryptoHash&lt;HASH_SIZE&gt;&amp; hash)&#10;    {&#10;        std::ios_base::fmtflags f(std::cout.flags());&#10;        for (int i = 0; i &lt; HASH_SIZE; i++)&#10;            os &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(8) &lt;&lt; hash.hashed_value[i];&#10;        std::cout.flags(f);&#10;        return os;&#10;    }&#10;&#10;};&#10;&#10;#endif&#10;" />
              <option name="updatedContent" value="/**&#10;* Taken from:&#10; * https://github.com/abbbaf/Compile-time-hash-functions&#10; * Licensed under the MIT License Copyright (c) 2021 Assaf Levi.&#10; */&#10;&#10;&#10;#ifndef CRYPTO_HASH_H&#10;#define CRYPTO_HASH_H&#10;&#10;#include &lt;iomanip&gt;&#10;#include &lt;cstdint&gt;&#10;#include &lt;iostream&gt;&#10;&#10;#include &quot;array.hpp&quot;&#10;#include &quot;utils.hpp&quot;&#10;&#10;#include &quot;circular_queue.hpp&quot;&#10;#include &quot;padded_value.hpp&quot;&#10;#include &quot;section.hpp&quot;&#10;&#10;//HASH_SIZE = (hash size in bits)/32&#10;&#10;template &lt;int HASH_SIZE&gt;&#10;class CryptoHash&#10;{&#10;&#10;private:&#10;    const Array&lt;uint32_t, HASH_SIZE&gt; hashed_value;&#10;&#10;protected:&#10;    constexpr CryptoHash(Array&lt;uint32_t, HASH_SIZE&gt; _hashed_value) :&#10;        hashed_value(_hashed_value) {}&#10;&#10;public:&#10;    bool operator ==(const CryptoHash&lt;HASH_SIZE&gt;&amp; second_hash) const&#10;    {&#10;        for (int i = 0; i &lt; HASH_SIZE; i++)&#10;        {&#10;            if (hashed_value[i] != second_hash.hashed_value[i])&#10;                return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;    bool operator !=(const CryptoHash&lt;HASH_SIZE&gt;&amp; second_hash) const&#10;    {&#10;        return !(*this == second_hash);&#10;    }&#10;&#10;    constexpr uint32_t operator [](int index) const&#10;    {&#10;        return hashed_value[index];&#10;    }&#10;&#10;&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CryptoHash&lt;HASH_SIZE&gt;&amp; hash)&#10;    {&#10;        std::ios_base::fmtflags f(std::cout.flags());&#10;        for (int i = 0; i &lt; HASH_SIZE; i++)&#10;            os &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(8) &lt;&lt; hash.hashed_value[i];&#10;        std::cout.flags(f);&#10;        return os;&#10;    }&#10;&#10;};&#10;&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/portal/engine/strings/hash/picohash.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/portal/engine/strings/hash/picohash.h" />
              <option name="originalContent" value="/*&#10; * The code is placed under public domain by Kazuho Oku &lt;kazuhooku@gmail.com&gt;.&#10; *&#10; * The MD5 implementation is based on a public domain implementation written by&#10; * Solar Designer &lt;solar@openwall.com&gt; in 2001, which is used by Dovecot.&#10; *&#10; * The SHA1 implementation is based on a public domain implementation written&#10; * by Wei Dai and other contributors for libcrypt, used also in liboauth.&#10; *&#10; * The SHA224/SHA256 implementation is based on a public domain implementation&#10; * by Sam Hocevar &lt;sam@hocevar.net&gt; for LibTomCrypt.&#10; */&#10;#ifndef _picohash_h_&#10;#define _picohash_h_&#10;&#10;#include &lt;assert.h&gt;&#10;#include &lt;inttypes.h&gt;&#10;#include &lt;string.h&gt;&#10;&#10;#ifdef __BIG_ENDIAN__&#10;#define _PICOHASH_BIG_ENDIAN&#10;#elif defined __LITTLE_ENDIAN__&#10;/* override */&#10;#elif defined __BYTE_ORDER&#10;#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__&#10;#define _PICOHASH_BIG_ENDIAN&#10;#endif&#10;#elif !defined(_WIN32)&#10;#include &lt;endian.h&gt; // machine/endian.h&#10;#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__&#10;#define _PICOHASH_BIG_ENDIAN&#10;#endif&#10;#endif&#10;&#10;#define PICOHASH_MD5_BLOCK_LENGTH 64&#10;#define PICOHASH_MD5_DIGEST_LENGTH 16&#10;&#10;typedef struct _picohash_md5_ctx_t {&#10;    uint_fast32_t lo, hi;&#10;    uint_fast32_t a, b, c, d;&#10;    unsigned char buffer[64];&#10;    uint_fast32_t block[PICOHASH_MD5_DIGEST_LENGTH];&#10;    const void *(*_body)(struct _picohash_md5_ctx_t *ctx, const void *data, size_t size);&#10;} _picohash_md5_ctx_t;&#10;&#10;static void _picohash_md5_init(_picohash_md5_ctx_t *ctx);&#10;static void _picohash_md5_update(_picohash_md5_ctx_t *ctx, const void *data, size_t size);&#10;static void _picohash_md5_final(_picohash_md5_ctx_t *ctx, void *digest);&#10;&#10;#define PICOHASH_SHA1_BLOCK_LENGTH 64&#10;#define PICOHASH_SHA1_DIGEST_LENGTH 20&#10;&#10;typedef struct {&#10;    uint32_t buffer[PICOHASH_SHA1_BLOCK_LENGTH / 4];&#10;    uint32_t state[PICOHASH_SHA1_DIGEST_LENGTH / 4];&#10;    uint64_t byteCount;&#10;    uint8_t bufferOffset;&#10;} _picohash_sha1_ctx_t;&#10;&#10;static void _picohash_sha1_init(_picohash_sha1_ctx_t *ctx);&#10;static void _picohash_sha1_update(_picohash_sha1_ctx_t *ctx, const void *input, size_t len);&#10;static void _picohash_sha1_final(_picohash_sha1_ctx_t *ctx, void *digest);&#10;&#10;#define PICOHASH_SHA256_BLOCK_LENGTH 64&#10;#define PICOHASH_SHA256_DIGEST_LENGTH 32&#10;#define PICOHASH_SHA224_BLOCK_LENGTH PICOHASH_SHA256_BLOCK_LENGTH&#10;#define PICOHASH_SHA224_DIGEST_LENGTH 28&#10;&#10;typedef struct {&#10;    uint64_t length;&#10;    uint32_t state[PICOHASH_SHA256_DIGEST_LENGTH / 4];&#10;    uint32_t curlen;&#10;    unsigned char buf[PICOHASH_SHA256_BLOCK_LENGTH];&#10;} _picohash_sha256_ctx_t;&#10;&#10;static void _picohash_sha256_init(_picohash_sha256_ctx_t *ctx);&#10;static void _picohash_sha256_update(_picohash_sha256_ctx_t *ctx, const void *data, size_t len);&#10;static void _picohash_sha256_final(_picohash_sha256_ctx_t *ctx, void *digest);&#10;static void _picohash_sha224_init(_picohash_sha256_ctx_t *ctx);&#10;static void _picohash_sha224_final(_picohash_sha256_ctx_t *ctx, void *digest);&#10;&#10;#define PICOHASH_MAX_BLOCK_LENGTH 64&#10;#define PICOHASH_MAX_DIGEST_LENGTH 32&#10;&#10;typedef struct {&#10;    union {&#10;        _picohash_md5_ctx_t _md5;&#10;        _picohash_sha1_ctx_t _sha1;&#10;        _picohash_sha256_ctx_t _sha256;&#10;    };&#10;    size_t block_length;&#10;    size_t digest_length;&#10;    void (*_reset)(void *ctx);&#10;    void (*_update)(void *ctx, const void *input, size_t len);&#10;    void (*_final)(void *ctx, void *digest);&#10;    struct {&#10;        unsigned char key[PICOHASH_MAX_BLOCK_LENGTH];&#10;        void (*hash_reset)(void *ctx);&#10;        void (*hash_final)(void *ctx, void *digest);&#10;    } _hmac;&#10;} picohash_ctx_t;&#10;&#10;static void picohash_init_md5(picohash_ctx_t *ctx);&#10;static void picohash_init_sha1(picohash_ctx_t *ctx);&#10;static void picohash_init_sha224(picohash_ctx_t *ctx);&#10;static void picohash_init_sha256(picohash_ctx_t *ctx);&#10;static void picohash_update(picohash_ctx_t *ctx, const void *input, size_t len);&#10;static void picohash_final(picohash_ctx_t *ctx, void *digest);&#10;static void picohash_reset(picohash_ctx_t *ctx);&#10;&#10;static void picohash_init_hmac(picohash_ctx_t *ctx, void (*initf)(picohash_ctx_t *), const void *key, size_t key_len);&#10;&#10;/* following are private definitions */&#10;&#10;/*&#10; * The basic MD5 functions.&#10; *&#10; * F is optimized compared to its RFC 1321 definition just like in Colin&#10; * Plumb's implementation.&#10; */&#10;#define _PICOHASH_MD5_F(x, y, z) ((z) ^ ((x) &amp; ((y) ^ (z))))&#10;#define _PICOHASH_MD5_G(x, y, z) ((y) ^ ((z) &amp; ((x) ^ (y))))&#10;#define _PICOHASH_MD5_H(x, y, z) ((x) ^ (y) ^ (z))&#10;#define _PICOHASH_MD5_I(x, y, z) ((y) ^ ((x) | ~(z)))&#10;&#10;/*&#10; * The MD5 transformation for all four rounds.&#10; */&#10;#define _PICOHASH_MD5_STEP(f, a, b, c, d, x, t, s)                                                                                 \&#10;    (a) += f((b), (c), (d)) + (x) + (t);                                                                                           \&#10;    (a) = (((a) &lt;&lt; (s)) | (((a)&amp;0xffffffff) &gt;&gt; (32 - (s))));                                                                       \&#10;    (a) += (b);&#10;&#10;/*&#10; * SET reads 4 input bytes in little-endian byte order and stores them&#10; * in a properly aligned word in host byte order.&#10; *&#10; * The check for little-endian architectures which tolerate unaligned&#10; * memory accesses is just an optimization.  Nothing will break if it&#10; * doesn't work.&#10; */&#10;#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)&#10;#define _PICOHASH_MD5_SET(n) (*(const uint32_t *)&amp;ptr[(n)*4])&#10;#define _PICOHASH_MD5_GET(n) _PICOHASH_MD5_SET(n)&#10;#else&#10;#define _PICOHASH_MD5_SET(n)                                                                                                       \&#10;    (ctx-&gt;block[(n)] = (uint_fast32_t)ptr[(n)*4] | ((uint_fast32_t)ptr[(n)*4 + 1] &lt;&lt; 8) | ((uint_fast32_t)ptr[(n)*4 + 2] &lt;&lt; 16) |  \&#10;                       ((uint_fast32_t)ptr[(n)*4 + 3] &lt;&lt; 24))&#10;#define _PICOHASH_MD5_GET(n) (ctx-&gt;block[(n)])&#10;#endif&#10;&#10;/*&#10; * This processes one or more 64-byte data blocks, but does NOT update&#10; * the bit counters.  There're no alignment requirements.&#10; */&#10;static const void *_picohash_md5_body(_picohash_md5_ctx_t *ctx, const void *data, size_t size)&#10;{&#10;    const unsigned char *ptr;&#10;    uint_fast32_t a, b, c, d;&#10;    uint_fast32_t saved_a, saved_b, saved_c, saved_d;&#10;&#10;    ptr = data;&#10;&#10;    a = ctx-&gt;a;&#10;    b = ctx-&gt;b;&#10;    c = ctx-&gt;c;&#10;    d = ctx-&gt;d;&#10;&#10;    do {&#10;        saved_a = a;&#10;        saved_b = b;&#10;        saved_c = c;&#10;        saved_d = d;&#10;&#10;        /* Round 1 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(0), 0xd76aa478, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(1), 0xe8c7b756, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(2), 0x242070db, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(3), 0xc1bdceee, 22)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(4), 0xf57c0faf, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(5), 0x4787c62a, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(6), 0xa8304613, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(7), 0xfd469501, 22)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(8), 0x698098d8, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(9), 0x8b44f7af, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(10), 0xffff5bb1, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(11), 0x895cd7be, 22)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(12), 0x6b901122, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(13), 0xfd987193, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(14), 0xa679438e, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(15), 0x49b40821, 22)&#10;&#10;        /* Round 2 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(1), 0xf61e2562, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(6), 0xc040b340, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(11), 0x265e5a51, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(0), 0xe9b6c7aa, 20)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(5), 0xd62f105d, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(10), 0x02441453, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(15), 0xd8a1e681, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(4), 0xe7d3fbc8, 20)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(9), 0x21e1cde6, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(14), 0xc33707d6, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(3), 0xf4d50d87, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(8), 0x455a14ed, 20)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(13), 0xa9e3e905, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(2), 0xfcefa3f8, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(7), 0x676f02d9, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(12), 0x8d2a4c8a, 20)&#10;&#10;        /* Round 3 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(5), 0xfffa3942, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(8), 0x8771f681, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(11), 0x6d9d6122, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(14), 0xfde5380c, 23)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(1), 0xa4beea44, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(4), 0x4bdecfa9, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(7), 0xf6bb4b60, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(10), 0xbebfbc70, 23)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(13), 0x289b7ec6, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(0), 0xeaa127fa, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(3), 0xd4ef3085, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(6), 0x04881d05, 23)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(9), 0xd9d4d039, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(12), 0xe6db99e5, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(15), 0x1fa27cf8, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(2), 0xc4ac5665, 23)&#10;&#10;        /* Round 4 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(0), 0xf4292244, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(7), 0x432aff97, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(14), 0xab9423a7, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(5), 0xfc93a039, 21)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(12), 0x655b59c3, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(3), 0x8f0ccc92, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(10), 0xffeff47d, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(1), 0x85845dd1, 21)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(8), 0x6fa87e4f, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(15), 0xfe2ce6e0, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(6), 0xa3014314, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(13), 0x4e0811a1, 21)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(4), 0xf7537e82, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(11), 0xbd3af235, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(2), 0x2ad7d2bb, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(9), 0xeb86d391, 21)&#10;&#10;        a += saved_a;&#10;        b += saved_b;&#10;        c += saved_c;&#10;        d += saved_d;&#10;&#10;        ptr += 64;&#10;    } while (size -= 64);&#10;&#10;    ctx-&gt;a = a;&#10;    ctx-&gt;b = b;&#10;    ctx-&gt;c = c;&#10;    ctx-&gt;d = d;&#10;&#10;    return ptr;&#10;}&#10;&#10;inline void _picohash_md5_init(_picohash_md5_ctx_t *ctx)&#10;{&#10;    ctx-&gt;a = 0x67452301;&#10;    ctx-&gt;b = 0xefcdab89;&#10;    ctx-&gt;c = 0x98badcfe;&#10;    ctx-&gt;d = 0x10325476;&#10;&#10;    ctx-&gt;lo = 0;&#10;    ctx-&gt;hi = 0;&#10;&#10;    ctx-&gt;_body = _picohash_md5_body;&#10;}&#10;&#10;inline void _picohash_md5_update(_picohash_md5_ctx_t *ctx, const void *data, size_t size)&#10;{&#10;    uint_fast32_t saved_lo;&#10;    unsigned long used, free;&#10;&#10;    saved_lo = ctx-&gt;lo;&#10;    if ((ctx-&gt;lo = (saved_lo + size) &amp; 0x1fffffff) &lt; saved_lo)&#10;        ctx-&gt;hi++;&#10;    ctx-&gt;hi += size &gt;&gt; 29;&#10;&#10;    used = saved_lo &amp; 0x3f;&#10;&#10;    if (used) {&#10;        free = 64 - used;&#10;&#10;        if (size &lt; free) {&#10;            memcpy(&amp;ctx-&gt;buffer[used], data, size);&#10;            return;&#10;        }&#10;&#10;        memcpy(&amp;ctx-&gt;buffer[used], data, free);&#10;        data = (const unsigned char *)data + free;&#10;        size -= free;&#10;        ctx-&gt;_body(ctx, ctx-&gt;buffer, 64);&#10;    }&#10;&#10;    if (size &gt;= 64) {&#10;        data = ctx-&gt;_body(ctx, data, size &amp; ~(unsigned long)0x3f);&#10;        size &amp;= 0x3f;&#10;    }&#10;&#10;    memcpy(ctx-&gt;buffer, data, size);&#10;}&#10;&#10;inline void _picohash_md5_final(_picohash_md5_ctx_t *ctx, void *_digest)&#10;{&#10;    unsigned char *digest = _digest;&#10;    unsigned long used, free;&#10;&#10;    used = ctx-&gt;lo &amp; 0x3f;&#10;&#10;    ctx-&gt;buffer[used++] = 0x80;&#10;&#10;    free = 64 - used;&#10;&#10;    if (free &lt; 8) {&#10;        memset(&amp;ctx-&gt;buffer[used], 0, free);&#10;        ctx-&gt;_body(ctx, ctx-&gt;buffer, 64);&#10;        used = 0;&#10;        free = 64;&#10;    }&#10;&#10;    memset(&amp;ctx-&gt;buffer[used], 0, free - 8);&#10;&#10;    ctx-&gt;lo &lt;&lt;= 3;&#10;    ctx-&gt;buffer[56] = ctx-&gt;lo;&#10;    ctx-&gt;buffer[57] = ctx-&gt;lo &gt;&gt; 8;&#10;    ctx-&gt;buffer[58] = ctx-&gt;lo &gt;&gt; 16;&#10;    ctx-&gt;buffer[59] = ctx-&gt;lo &gt;&gt; 24;&#10;    ctx-&gt;buffer[60] = ctx-&gt;hi;&#10;    ctx-&gt;buffer[61] = ctx-&gt;hi &gt;&gt; 8;&#10;    ctx-&gt;buffer[62] = ctx-&gt;hi &gt;&gt; 16;&#10;    ctx-&gt;buffer[63] = ctx-&gt;hi &gt;&gt; 24;&#10;&#10;    ctx-&gt;_body(ctx, ctx-&gt;buffer, 64);&#10;&#10;    digest[0] = ctx-&gt;a;&#10;    digest[1] = ctx-&gt;a &gt;&gt; 8;&#10;    digest[2] = ctx-&gt;a &gt;&gt; 16;&#10;    digest[3] = ctx-&gt;a &gt;&gt; 24;&#10;    digest[4] = ctx-&gt;b;&#10;    digest[5] = ctx-&gt;b &gt;&gt; 8;&#10;    digest[6] = ctx-&gt;b &gt;&gt; 16;&#10;    digest[7] = ctx-&gt;b &gt;&gt; 24;&#10;    digest[8] = ctx-&gt;c;&#10;    digest[9] = ctx-&gt;c &gt;&gt; 8;&#10;    digest[10] = ctx-&gt;c &gt;&gt; 16;&#10;    digest[11] = ctx-&gt;c &gt;&gt; 24;&#10;    digest[12] = ctx-&gt;d;&#10;    digest[13] = ctx-&gt;d &gt;&gt; 8;&#10;    digest[14] = ctx-&gt;d &gt;&gt; 16;&#10;    digest[15] = ctx-&gt;d &gt;&gt; 24;&#10;&#10;    memset(ctx, 0, sizeof(*ctx));&#10;}&#10;&#10;#define _PICOHASH_SHA1_K0 0x5a827999&#10;#define _PICOHASH_SHA1_K20 0x6ed9eba1&#10;#define _PICOHASH_SHA1_K40 0x8f1bbcdc&#10;#define _PICOHASH_SHA1_K60 0xca62c1d6&#10;&#10;static inline uint32_t _picohash_sha1_rol32(uint32_t number, uint8_t bits)&#10;{&#10;    return ((number &lt;&lt; bits) | (number &gt;&gt; (32 - bits)));&#10;}&#10;&#10;static inline void _picohash_sha1_hash_block(_picohash_sha1_ctx_t *s)&#10;{&#10;    uint8_t i;&#10;    uint32_t a, b, c, d, e, t;&#10;&#10;    a = s-&gt;state[0];&#10;    b = s-&gt;state[1];&#10;    c = s-&gt;state[2];&#10;    d = s-&gt;state[3];&#10;    e = s-&gt;state[4];&#10;    for (i = 0; i &lt; 80; i++) {&#10;        if (i &gt;= 16) {&#10;            t = s-&gt;buffer[(i + 13) &amp; 15] ^ s-&gt;buffer[(i + 8) &amp; 15] ^ s-&gt;buffer[(i + 2) &amp; 15] ^ s-&gt;buffer[i &amp; 15];&#10;            s-&gt;buffer[i &amp; 15] = _picohash_sha1_rol32(t, 1);&#10;        }&#10;        if (i &lt; 20) {&#10;            t = (d ^ (b &amp; (c ^ d))) + _PICOHASH_SHA1_K0;&#10;        } else if (i &lt; 40) {&#10;            t = (b ^ c ^ d) + _PICOHASH_SHA1_K20;&#10;        } else if (i &lt; 60) {&#10;            t = ((b &amp; c) | (d &amp; (b | c))) + _PICOHASH_SHA1_K40;&#10;        } else {&#10;            t = (b ^ c ^ d) + _PICOHASH_SHA1_K60;&#10;        }&#10;        t += _picohash_sha1_rol32(a, 5) + e + s-&gt;buffer[i &amp; 15];&#10;        e = d;&#10;        d = c;&#10;        c = _picohash_sha1_rol32(b, 30);&#10;        b = a;&#10;        a = t;&#10;    }&#10;    s-&gt;state[0] += a;&#10;    s-&gt;state[1] += b;&#10;    s-&gt;state[2] += c;&#10;    s-&gt;state[3] += d;&#10;    s-&gt;state[4] += e;&#10;}&#10;&#10;static inline void _picohash_sha1_add_uncounted(_picohash_sha1_ctx_t *s, uint8_t data)&#10;{&#10;    uint8_t *const b = (uint8_t *)s-&gt;buffer;&#10;#ifdef _PICOHASH_BIG_ENDIAN&#10;    b[s-&gt;bufferOffset] = data;&#10;#else&#10;    b[s-&gt;bufferOffset ^ 3] = data;&#10;#endif&#10;    s-&gt;bufferOffset++;&#10;    if (s-&gt;bufferOffset == PICOHASH_SHA1_BLOCK_LENGTH) {&#10;        _picohash_sha1_hash_block(s);&#10;        s-&gt;bufferOffset = 0;&#10;    }&#10;}&#10;&#10;inline void _picohash_sha1_init(_picohash_sha1_ctx_t *s)&#10;{&#10;    s-&gt;state[0] = 0x67452301;&#10;    s-&gt;state[1] = 0xefcdab89;&#10;    s-&gt;state[2] = 0x98badcfe;&#10;    s-&gt;state[3] = 0x10325476;&#10;    s-&gt;state[4] = 0xc3d2e1f0;&#10;    s-&gt;byteCount = 0;&#10;    s-&gt;bufferOffset = 0;&#10;}&#10;&#10;inline void _picohash_sha1_update(_picohash_sha1_ctx_t *s, const void *_data, size_t len)&#10;{&#10;    const uint8_t *data = _data;&#10;    for (; len != 0; --len) {&#10;        ++s-&gt;byteCount;&#10;        _picohash_sha1_add_uncounted(s, *data++);&#10;    }&#10;}&#10;&#10;inline void _picohash_sha1_final(_picohash_sha1_ctx_t *s, void *digest)&#10;{&#10;    // Pad with 0x80 followed by 0x00 until the end of the block&#10;    _picohash_sha1_add_uncounted(s, 0x80);&#10;    while (s-&gt;bufferOffset != 56)&#10;        _picohash_sha1_add_uncounted(s, 0x00);&#10;&#10;    // Append length in the last 8 bytes&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 53); // Shifting to multiply by 8&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 45); // as SHA-1 supports bitstreams as well as&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 37); // byte.&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 29);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 21);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 13);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 5);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &lt;&lt; 3);&#10;&#10;#ifndef SHA_BIG_ENDIAN&#10;    { // Swap byte order back&#10;        int i;&#10;        for (i = 0; i &lt; 5; i++) {&#10;            s-&gt;state[i] = (((s-&gt;state[i]) &lt;&lt; 24) &amp; 0xff000000) | (((s-&gt;state[i]) &lt;&lt; 8) &amp; 0x00ff0000) |&#10;                          (((s-&gt;state[i]) &gt;&gt; 8) &amp; 0x0000ff00) | (((s-&gt;state[i]) &gt;&gt; 24) &amp; 0x000000ff);&#10;        }&#10;    }&#10;#endif&#10;&#10;    memcpy(digest, s-&gt;state, sizeof(s-&gt;state));&#10;}&#10;&#10;#define _picohash_sha256_ch(x, y, z) (z ^ (x &amp; (y ^ z)))&#10;#define _picohash_sha256_maj(x, y, z) (((x | y) &amp; z) | (x &amp; y))&#10;#define _picohash_sha256_s(x, y)                                                                                                   \&#10;    (((((uint32_t)(x)&amp;0xFFFFFFFFUL) &gt;&gt; (uint32_t)((y)&amp;31)) | ((uint32_t)(x) &lt;&lt; (uint32_t)(32 - ((y)&amp;31)))) &amp; 0xFFFFFFFFUL)&#10;#define _picohash_sha256_r(x, n) (((x)&amp;0xFFFFFFFFUL) &gt;&gt; (n))&#10;#define _picohash_sha256_sigma0(x) (_picohash_sha256_s(x, 2) ^ _picohash_sha256_s(x, 13) ^ _picohash_sha256_s(x, 22))&#10;#define _picohash_sha256_sigma1(x) (_picohash_sha256_s(x, 6) ^ _picohash_sha256_s(x, 11) ^ _picohash_sha256_s(x, 25))&#10;#define _picohash_sha256_gamma0(x) (_picohash_sha256_s(x, 7) ^ _picohash_sha256_s(x, 18) ^ _picohash_sha256_r(x, 3))&#10;#define _picohash_sha256_gamma1(x) (_picohash_sha256_s(x, 17) ^ _picohash_sha256_s(x, 19) ^ _picohash_sha256_r(x, 10))&#10;#define _picohash_sha256_rnd(a, b, c, d, e, f, g, h, i)                                                                            \&#10;    t0 = h + _picohash_sha256_sigma1(e) + _picohash_sha256_ch(e, f, g) + K[i] + W[i];                                              \&#10;    t1 = _picohash_sha256_sigma0(a) + _picohash_sha256_maj(a, b, c);                                                               \&#10;    d += t0;                                                                                                                       \&#10;    h = t0 + t1;&#10;&#10;static inline void _picohash_sha256_compress(_picohash_sha256_ctx_t *ctx, unsigned char *buf)&#10;{&#10;    static const uint32_t K[64] = {&#10;        0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,&#10;        0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,&#10;        0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL, 0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,&#10;        0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,&#10;        0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,&#10;        0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,&#10;        0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,&#10;        0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL, 0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL};&#10;    uint32_t S[8], W[64], t, t0, t1;&#10;    int i;&#10;&#10;    /* copy state into S */&#10;    for (i = 0; i &lt; 8; i++)&#10;        S[i] = ctx-&gt;state[i];&#10;&#10;    /* copy the state into 512-bits into W[0..15] */&#10;    for (i = 0; i &lt; 16; i++)&#10;        W[i] =&#10;            (uint32_t)buf[4 * i] &lt;&lt; 24 | (uint32_t)buf[4 * i + 1] &lt;&lt; 16 | (uint32_t)buf[4 * i + 2] &lt;&lt; 8 | (uint32_t)buf[4 * i + 3];&#10;&#10;    /* fill W[16..63] */&#10;    for (i = 16; i &lt; 64; i++)&#10;        W[i] = _picohash_sha256_gamma1(W[i - 2]) + W[i - 7] + _picohash_sha256_gamma0(W[i - 15]) + W[i - 16];&#10;&#10;    /* Compress */&#10;    for (i = 0; i &lt; 64; ++i) {&#10;        _picohash_sha256_rnd(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);&#10;        t = S[7];&#10;        S[7] = S[6];&#10;        S[6] = S[5];&#10;        S[5] = S[4];&#10;        S[4] = S[3];&#10;        S[3] = S[2];&#10;        S[2] = S[1];&#10;        S[1] = S[0];&#10;        S[0] = t;&#10;    }&#10;&#10;    /* feedback */&#10;    for (i = 0; i &lt; 8; i++)&#10;        ctx-&gt;state[i] = ctx-&gt;state[i] + S[i];&#10;}&#10;&#10;static inline void _picohash_sha256_do_final(_picohash_sha256_ctx_t *ctx, void *digest, size_t len)&#10;{&#10;    unsigned char *out = digest;&#10;    size_t i;&#10;&#10;    /* increase the length of the message */&#10;    ctx-&gt;length += ctx-&gt;curlen * 8;&#10;&#10;    /* append the '1' bit */&#10;    ctx-&gt;buf[ctx-&gt;curlen++] = (unsigned char)0x80;&#10;&#10;    /* if the length is currently above 56 bytes we append zeros&#10;     * then compress.  Then we can fall back to padding zeros and length&#10;     * encoding like normal.&#10;     */&#10;    if (ctx-&gt;curlen &gt; 56) {&#10;        while (ctx-&gt;curlen &lt; 64) {&#10;            ctx-&gt;buf[ctx-&gt;curlen++] = (unsigned char)0;&#10;        }&#10;        _picohash_sha256_compress(ctx, ctx-&gt;buf);&#10;        ctx-&gt;curlen = 0;&#10;    }&#10;&#10;    /* pad upto 56 bytes of zeroes */&#10;    while (ctx-&gt;curlen &lt; 56) {&#10;        ctx-&gt;buf[ctx-&gt;curlen++] = (unsigned char)0;&#10;    }&#10;&#10;    /* store length */&#10;    for (i = 0; i != 8; ++i)&#10;        ctx-&gt;buf[56 + i] = ctx-&gt;length &gt;&gt; (56 - 8 * i);&#10;    _picohash_sha256_compress(ctx, ctx-&gt;buf);&#10;&#10;    /* copy output */&#10;    for (i = 0; i != len / 4; ++i) {&#10;        out[i * 4] = ctx-&gt;state[i] &gt;&gt; 24;&#10;        out[i * 4 + 1] = ctx-&gt;state[i] &gt;&gt; 16;&#10;        out[i * 4 + 2] = ctx-&gt;state[i] &gt;&gt; 8;&#10;        out[i * 4 + 3] = ctx-&gt;state[i];&#10;    }&#10;}&#10;&#10;inline void _picohash_sha256_init(_picohash_sha256_ctx_t *ctx)&#10;{&#10;    ctx-&gt;curlen = 0;&#10;    ctx-&gt;length = 0;&#10;    ctx-&gt;state[0] = 0x6A09E667UL;&#10;    ctx-&gt;state[1] = 0xBB67AE85UL;&#10;    ctx-&gt;state[2] = 0x3C6EF372UL;&#10;    ctx-&gt;state[3] = 0xA54FF53AUL;&#10;    ctx-&gt;state[4] = 0x510E527FUL;&#10;    ctx-&gt;state[5] = 0x9B05688CUL;&#10;    ctx-&gt;state[6] = 0x1F83D9ABUL;&#10;    ctx-&gt;state[7] = 0x5BE0CD19UL;&#10;}&#10;&#10;inline void _picohash_sha256_update(_picohash_sha256_ctx_t *ctx, const void *data, size_t len)&#10;{&#10;    const unsigned char *in = data;&#10;    size_t n;&#10;&#10;    while (len &gt; 0) {&#10;        if (ctx-&gt;curlen == 0 &amp;&amp; len &gt;= PICOHASH_SHA256_BLOCK_LENGTH) {&#10;            _picohash_sha256_compress(ctx, (unsigned char *)in);&#10;            ctx-&gt;length += PICOHASH_SHA256_BLOCK_LENGTH * 8;&#10;            in += PICOHASH_SHA256_BLOCK_LENGTH;&#10;            len -= PICOHASH_SHA256_BLOCK_LENGTH;&#10;        } else {&#10;            n = PICOHASH_SHA256_BLOCK_LENGTH - ctx-&gt;curlen;&#10;            if (n &gt; len)&#10;                n = len;&#10;            memcpy(ctx-&gt;buf + ctx-&gt;curlen, in, (size_t)n);&#10;            ctx-&gt;curlen += n;&#10;            in += n;&#10;            len -= n;&#10;            if (ctx-&gt;curlen == 64) {&#10;                _picohash_sha256_compress(ctx, ctx-&gt;buf);&#10;                ctx-&gt;length += 8 * PICOHASH_SHA256_BLOCK_LENGTH;&#10;                ctx-&gt;curlen = 0;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;inline void _picohash_sha256_final(_picohash_sha256_ctx_t *ctx, void *digest)&#10;{&#10;    _picohash_sha256_do_final(ctx, digest, PICOHASH_SHA256_DIGEST_LENGTH);&#10;}&#10;&#10;inline void _picohash_sha224_init(_picohash_sha256_ctx_t *ctx)&#10;{&#10;    ctx-&gt;curlen = 0;&#10;    ctx-&gt;length = 0;&#10;    ctx-&gt;state[0] = 0xc1059ed8UL;&#10;    ctx-&gt;state[1] = 0x367cd507UL;&#10;    ctx-&gt;state[2] = 0x3070dd17UL;&#10;    ctx-&gt;state[3] = 0xf70e5939UL;&#10;    ctx-&gt;state[4] = 0xffc00b31UL;&#10;    ctx-&gt;state[5] = 0x68581511UL;&#10;    ctx-&gt;state[6] = 0x64f98fa7UL;&#10;    ctx-&gt;state[7] = 0xbefa4fa4UL;&#10;}&#10;&#10;inline void _picohash_sha224_final(_picohash_sha256_ctx_t *ctx, void *digest)&#10;{&#10;    _picohash_sha256_do_final(ctx, digest, PICOHASH_SHA224_DIGEST_LENGTH);&#10;}&#10;&#10;inline void picohash_init_md5(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_MD5_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_MD5_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_md5_init;&#10;    ctx-&gt;_update = (void *)_picohash_md5_update;&#10;    ctx-&gt;_final = (void *)_picohash_md5_final;&#10;&#10;    _picohash_md5_init(&amp;ctx-&gt;_md5);&#10;}&#10;&#10;inline void picohash_init_sha1(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_SHA1_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_SHA1_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_sha1_init;&#10;    ctx-&gt;_update = (void *)_picohash_sha1_update;&#10;    ctx-&gt;_final = (void *)_picohash_sha1_final;&#10;    _picohash_sha1_init(&amp;ctx-&gt;_sha1);&#10;}&#10;&#10;inline void picohash_init_sha224(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_SHA224_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_SHA224_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_sha224_init;&#10;    ctx-&gt;_update = (void *)_picohash_sha256_update;&#10;    ctx-&gt;_final = (void *)_picohash_sha224_final;&#10;    _picohash_sha224_init(&amp;ctx-&gt;_sha256);&#10;}&#10;&#10;inline void picohash_init_sha256(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_SHA256_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_SHA256_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_sha256_init;&#10;    ctx-&gt;_update = (void *)_picohash_sha256_update;&#10;    ctx-&gt;_final = (void *)_picohash_sha256_final;&#10;    _picohash_sha256_init(&amp;ctx-&gt;_sha256);&#10;}&#10;&#10;inline void picohash_update(picohash_ctx_t *ctx, const void *input, size_t len)&#10;{&#10;    ctx-&gt;_update(ctx, input, len);&#10;}&#10;&#10;inline void picohash_final(picohash_ctx_t *ctx, void *digest)&#10;{&#10;    ctx-&gt;_final(ctx, digest);&#10;}&#10;&#10;inline void picohash_reset(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;_reset(ctx);&#10;}&#10;&#10;static inline void _picohash_hmac_apply_key(picohash_ctx_t *ctx, unsigned char delta)&#10;{&#10;    size_t i;&#10;    for (i = 0; i != ctx-&gt;block_length; ++i)&#10;        ctx-&gt;_hmac.key[i] ^= delta;&#10;    picohash_update(ctx, ctx-&gt;_hmac.key, ctx-&gt;block_length);&#10;    for (i = 0; i != ctx-&gt;block_length; ++i)&#10;        ctx-&gt;_hmac.key[i] ^= delta;&#10;}&#10;&#10;static void _picohash_hmac_final(picohash_ctx_t *ctx, void *digest)&#10;{&#10;    unsigned char inner_digest[PICOHASH_MAX_DIGEST_LENGTH];&#10;&#10;    ctx-&gt;_hmac.hash_final(ctx, inner_digest);&#10;&#10;    ctx-&gt;_hmac.hash_reset(ctx);&#10;    _picohash_hmac_apply_key(ctx, 0x5c);&#10;    picohash_update(ctx, inner_digest, ctx-&gt;digest_length);&#10;    memset(inner_digest, 0, ctx-&gt;digest_length);&#10;&#10;    ctx-&gt;_hmac.hash_final(ctx, digest);&#10;}&#10;&#10;static inline void _picohash_hmac_reset(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;_hmac.hash_reset(ctx);&#10;    _picohash_hmac_apply_key(ctx, 0x36);&#10;}&#10;&#10;inline void picohash_init_hmac(picohash_ctx_t *ctx, void (*initf)(picohash_ctx_t *), const void *key, size_t key_len)&#10;{&#10;    initf(ctx);&#10;&#10;    memset(ctx-&gt;_hmac.key, 0, ctx-&gt;block_length);&#10;    if (key_len &gt; ctx-&gt;block_length) {&#10;        /* hash the key if it is too long */&#10;        picohash_update(ctx, key, key_len);&#10;        picohash_final(ctx, ctx-&gt;_hmac.key);&#10;        ctx-&gt;_hmac.hash_reset(ctx);&#10;    } else {&#10;        memcpy(ctx-&gt;_hmac.key, key, key_len);&#10;    }&#10;&#10;    /* replace reset and final function */&#10;    ctx-&gt;_hmac.hash_reset = ctx-&gt;_reset;&#10;    ctx-&gt;_hmac.hash_final = ctx-&gt;_final;&#10;    ctx-&gt;_reset = (void *)_picohash_hmac_reset;&#10;    ctx-&gt;_final = (void *)_picohash_hmac_final;&#10;&#10;    /* start calculating the inner hash */&#10;    _picohash_hmac_apply_key(ctx, 0x36);&#10;}&#10;&#10;#endif" />
              <option name="updatedContent" value="/*&#10; * The code is placed under public domain by Kazuho Oku &lt;kazuhooku@gmail.com&gt;.&#10; *&#10; * The MD5 implementation is based on a public domain implementation written by&#10; * Solar Designer &lt;solar@openwall.com&gt; in 2001, which is used by Dovecot.&#10; *&#10; * The SHA1 implementation is based on a public domain implementation written&#10; * by Wei Dai and other contributors for libcrypt, used also in liboauth.&#10; *&#10; * The SHA224/SHA256 implementation is based on a public domain implementation&#10; * by Sam Hocevar &lt;sam@hocevar.net&gt; for LibTomCrypt.&#10; */&#10;#ifndef _picohash_h_&#10;#define _picohash_h_&#10;&#10;#include &lt;assert.h&gt;&#10;#include &lt;inttypes.h&gt;&#10;#include &lt;string.h&gt;&#10;&#10;#ifdef __BIG_ENDIAN__&#10;#define _PICOHASH_BIG_ENDIAN&#10;#elif defined __LITTLE_ENDIAN__&#10;/* override */&#10;#elif defined __BYTE_ORDER&#10;#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__&#10;#define _PICOHASH_BIG_ENDIAN&#10;#endif&#10;#elif !defined(_WIN32)&#10;#include &lt;endian.h&gt; // machine/endian.h&#10;#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__&#10;#define _PICOHASH_BIG_ENDIAN&#10;#endif&#10;#endif&#10;&#10;#define PICOHASH_MD5_BLOCK_LENGTH 64&#10;#define PICOHASH_MD5_DIGEST_LENGTH 16&#10;&#10;typedef struct _picohash_md5_ctx_t {&#10;    uint_fast32_t lo, hi;&#10;    uint_fast32_t a, b, c, d;&#10;    unsigned char buffer[64];&#10;    uint_fast32_t block[PICOHASH_MD5_DIGEST_LENGTH];&#10;    const void *(*_body)(struct _picohash_md5_ctx_t *ctx, const void *data, size_t size);&#10;} _picohash_md5_ctx_t;&#10;&#10;static void _picohash_md5_init(_picohash_md5_ctx_t *ctx);&#10;static void _picohash_md5_update(_picohash_md5_ctx_t *ctx, const void *data, size_t size);&#10;static void _picohash_md5_final(_picohash_md5_ctx_t *ctx, void *digest);&#10;&#10;#define PICOHASH_SHA1_BLOCK_LENGTH 64&#10;#define PICOHASH_SHA1_DIGEST_LENGTH 20&#10;&#10;typedef struct {&#10;    uint32_t buffer[PICOHASH_SHA1_BLOCK_LENGTH / 4];&#10;    uint32_t state[PICOHASH_SHA1_DIGEST_LENGTH / 4];&#10;    uint64_t byteCount;&#10;    uint8_t bufferOffset;&#10;} _picohash_sha1_ctx_t;&#10;&#10;static void _picohash_sha1_init(_picohash_sha1_ctx_t *ctx);&#10;static void _picohash_sha1_update(_picohash_sha1_ctx_t *ctx, const void *input, size_t len);&#10;static void _picohash_sha1_final(_picohash_sha1_ctx_t *ctx, void *digest);&#10;&#10;#define PICOHASH_SHA256_BLOCK_LENGTH 64&#10;#define PICOHASH_SHA256_DIGEST_LENGTH 32&#10;#define PICOHASH_SHA224_BLOCK_LENGTH PICOHASH_SHA256_BLOCK_LENGTH&#10;#define PICOHASH_SHA224_DIGEST_LENGTH 28&#10;&#10;typedef struct {&#10;    uint64_t length;&#10;    uint32_t state[PICOHASH_SHA256_DIGEST_LENGTH / 4];&#10;    uint32_t curlen;&#10;    unsigned char buf[PICOHASH_SHA256_BLOCK_LENGTH];&#10;} _picohash_sha256_ctx_t;&#10;&#10;static void _picohash_sha256_init(_picohash_sha256_ctx_t *ctx);&#10;static void _picohash_sha256_update(_picohash_sha256_ctx_t *ctx, const void *data, size_t len);&#10;static void _picohash_sha256_final(_picohash_sha256_ctx_t *ctx, void *digest);&#10;static void _picohash_sha224_init(_picohash_sha256_ctx_t *ctx);&#10;static void _picohash_sha224_final(_picohash_sha256_ctx_t *ctx, void *digest);&#10;&#10;#define PICOHASH_MAX_BLOCK_LENGTH 64&#10;#define PICOHASH_MAX_DIGEST_LENGTH 32&#10;&#10;typedef struct {&#10;    union {&#10;        _picohash_md5_ctx_t _md5;&#10;        _picohash_sha1_ctx_t _sha1;&#10;        _picohash_sha256_ctx_t _sha256;&#10;    };&#10;    size_t block_length;&#10;    size_t digest_length;&#10;    void (*_reset)(void *ctx);&#10;    void (*_update)(void *ctx, const void *input, size_t len);&#10;    void (*_final)(void *ctx, void *digest);&#10;    struct {&#10;        unsigned char key[PICOHASH_MAX_BLOCK_LENGTH];&#10;        void (*hash_reset)(void *ctx);&#10;        void (*hash_final)(void *ctx, void *digest);&#10;    } _hmac;&#10;} picohash_ctx_t;&#10;&#10;static void picohash_init_md5(picohash_ctx_t *ctx);&#10;static void picohash_init_sha1(picohash_ctx_t *ctx);&#10;static void picohash_init_sha224(picohash_ctx_t *ctx);&#10;static void picohash_init_sha256(picohash_ctx_t *ctx);&#10;static void picohash_update(picohash_ctx_t *ctx, const void *input, size_t len);&#10;static void picohash_final(picohash_ctx_t *ctx, void *digest);&#10;static void picohash_reset(picohash_ctx_t *ctx);&#10;&#10;static void picohash_init_hmac(picohash_ctx_t *ctx, void (*initf)(picohash_ctx_t *), const void *key, size_t key_len);&#10;&#10;/* following are private definitions */&#10;&#10;/*&#10; * The basic MD5 functions.&#10; *&#10; * F is optimized compared to its RFC 1321 definition just like in Colin&#10; * Plumb's implementation.&#10; */&#10;#define _PICOHASH_MD5_F(x, y, z) ((z) ^ ((x) &amp; ((y) ^ (z))))&#10;#define _PICOHASH_MD5_G(x, y, z) ((y) ^ ((z) &amp; ((x) ^ (y))))&#10;#define _PICOHASH_MD5_H(x, y, z) ((x) ^ (y) ^ (z))&#10;#define _PICOHASH_MD5_I(x, y, z) ((y) ^ ((x) | ~(z)))&#10;&#10;/*&#10; * The MD5 transformation for all four rounds.&#10; */&#10;#define _PICOHASH_MD5_STEP(f, a, b, c, d, x, t, s)                                                                                 \&#10;    (a) += f((b), (c), (d)) + (x) + (t);                                                                                           \&#10;    (a) = (((a) &lt;&lt; (s)) | (((a)&amp;0xffffffff) &gt;&gt; (32 - (s))));                                                                       \&#10;    (a) += (b);&#10;&#10;/*&#10; * SET reads 4 input bytes in little-endian byte order and stores them&#10; * in a properly aligned word in host byte order.&#10; *&#10; * The check for little-endian architectures which tolerate unaligned&#10; * memory accesses is just an optimization.  Nothing will break if it&#10; * doesn't work.&#10; */&#10;#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)&#10;#define _PICOHASH_MD5_SET(n) (*(const uint32_t *)&amp;ptr[(n)*4])&#10;#define _PICOHASH_MD5_GET(n) _PICOHASH_MD5_SET(n)&#10;#else&#10;#define _PICOHASH_MD5_SET(n)                                                                                                       \&#10;    (ctx-&gt;block[(n)] = (uint_fast32_t)ptr[(n)*4] | ((uint_fast32_t)ptr[(n)*4 + 1] &lt;&lt; 8) | ((uint_fast32_t)ptr[(n)*4 + 2] &lt;&lt; 16) |  \&#10;                       ((uint_fast32_t)ptr[(n)*4 + 3] &lt;&lt; 24))&#10;#define _PICOHASH_MD5_GET(n) (ctx-&gt;block[(n)])&#10;#endif&#10;&#10;/*&#10; * This processes one or more 64-byte data blocks, but does NOT update&#10; * the bit counters.  There're no alignment requirements.&#10; */&#10;static const void *_picohash_md5_body(_picohash_md5_ctx_t *ctx, const void *data, size_t size)&#10;{&#10;    const unsigned char *ptr;&#10;    uint_fast32_t a, b, c, d;&#10;    uint_fast32_t saved_a, saved_b, saved_c, saved_d;&#10;&#10;    ptr = data;&#10;&#10;    a = ctx-&gt;a;&#10;    b = ctx-&gt;b;&#10;    c = ctx-&gt;c;&#10;    d = ctx-&gt;d;&#10;&#10;    do {&#10;        saved_a = a;&#10;        saved_b = b;&#10;        saved_c = c;&#10;        saved_d = d;&#10;&#10;        /* Round 1 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(0), 0xd76aa478, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(1), 0xe8c7b756, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(2), 0x242070db, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(3), 0xc1bdceee, 22)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(4), 0xf57c0faf, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(5), 0x4787c62a, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(6), 0xa8304613, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(7), 0xfd469501, 22)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(8), 0x698098d8, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(9), 0x8b44f7af, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(10), 0xffff5bb1, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(11), 0x895cd7be, 22)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, a, b, c, d, _PICOHASH_MD5_SET(12), 0x6b901122, 7)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, d, a, b, c, _PICOHASH_MD5_SET(13), 0xfd987193, 12)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, c, d, a, b, _PICOHASH_MD5_SET(14), 0xa679438e, 17)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_F, b, c, d, a, _PICOHASH_MD5_SET(15), 0x49b40821, 22)&#10;&#10;        /* Round 2 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(1), 0xf61e2562, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(6), 0xc040b340, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(11), 0x265e5a51, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(0), 0xe9b6c7aa, 20)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(5), 0xd62f105d, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(10), 0x02441453, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(15), 0xd8a1e681, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(4), 0xe7d3fbc8, 20)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(9), 0x21e1cde6, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(14), 0xc33707d6, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(3), 0xf4d50d87, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(8), 0x455a14ed, 20)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, a, b, c, d, _PICOHASH_MD5_GET(13), 0xa9e3e905, 5)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, d, a, b, c, _PICOHASH_MD5_GET(2), 0xfcefa3f8, 9)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, c, d, a, b, _PICOHASH_MD5_GET(7), 0x676f02d9, 14)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_G, b, c, d, a, _PICOHASH_MD5_GET(12), 0x8d2a4c8a, 20)&#10;&#10;        /* Round 3 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(5), 0xfffa3942, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(8), 0x8771f681, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(11), 0x6d9d6122, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(14), 0xfde5380c, 23)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(1), 0xa4beea44, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(4), 0x4bdecfa9, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(7), 0xf6bb4b60, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(10), 0xbebfbc70, 23)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(13), 0x289b7ec6, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(0), 0xeaa127fa, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(3), 0xd4ef3085, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(6), 0x04881d05, 23)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, a, b, c, d, _PICOHASH_MD5_GET(9), 0xd9d4d039, 4)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, d, a, b, c, _PICOHASH_MD5_GET(12), 0xe6db99e5, 11)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, c, d, a, b, _PICOHASH_MD5_GET(15), 0x1fa27cf8, 16)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_H, b, c, d, a, _PICOHASH_MD5_GET(2), 0xc4ac5665, 23)&#10;&#10;        /* Round 4 */&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(0), 0xf4292244, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(7), 0x432aff97, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(14), 0xab9423a7, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(5), 0xfc93a039, 21)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(12), 0x655b59c3, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(3), 0x8f0ccc92, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(10), 0xffeff47d, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(1), 0x85845dd1, 21)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(8), 0x6fa87e4f, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(15), 0xfe2ce6e0, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(6), 0xa3014314, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(13), 0x4e0811a1, 21)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, a, b, c, d, _PICOHASH_MD5_GET(4), 0xf7537e82, 6)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, d, a, b, c, _PICOHASH_MD5_GET(11), 0xbd3af235, 10)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, c, d, a, b, _PICOHASH_MD5_GET(2), 0x2ad7d2bb, 15)&#10;        _PICOHASH_MD5_STEP(_PICOHASH_MD5_I, b, c, d, a, _PICOHASH_MD5_GET(9), 0xeb86d391, 21)&#10;&#10;        a += saved_a;&#10;        b += saved_b;&#10;        c += saved_c;&#10;        d += saved_d;&#10;&#10;        ptr += 64;&#10;    } while (size -= 64);&#10;&#10;    ctx-&gt;a = a;&#10;    ctx-&gt;b = b;&#10;    ctx-&gt;c = c;&#10;    ctx-&gt;d = d;&#10;&#10;    return ptr;&#10;}&#10;&#10;inline void _picohash_md5_init(_picohash_md5_ctx_t *ctx)&#10;{&#10;    ctx-&gt;a = 0x67452301;&#10;    ctx-&gt;b = 0xefcdab89;&#10;    ctx-&gt;c = 0x98badcfe;&#10;    ctx-&gt;d = 0x10325476;&#10;&#10;    ctx-&gt;lo = 0;&#10;    ctx-&gt;hi = 0;&#10;&#10;    ctx-&gt;_body = _picohash_md5_body;&#10;}&#10;&#10;inline void _picohash_md5_update(_picohash_md5_ctx_t *ctx, const void *data, size_t size)&#10;{&#10;    uint_fast32_t saved_lo;&#10;    unsigned long used, free;&#10;&#10;    saved_lo = ctx-&gt;lo;&#10;    if ((ctx-&gt;lo = (saved_lo + size) &amp; 0x1fffffff) &lt; saved_lo)&#10;        ctx-&gt;hi++;&#10;    ctx-&gt;hi += size &gt;&gt; 29;&#10;&#10;    used = saved_lo &amp; 0x3f;&#10;&#10;    if (used) {&#10;        free = 64 - used;&#10;&#10;        if (size &lt; free) {&#10;            memcpy(&amp;ctx-&gt;buffer[used], data, size);&#10;            return;&#10;        }&#10;&#10;        memcpy(&amp;ctx-&gt;buffer[used], data, free);&#10;        data = (const unsigned char *)data + free;&#10;        size -= free;&#10;        ctx-&gt;_body(ctx, ctx-&gt;buffer, 64);&#10;    }&#10;&#10;    if (size &gt;= 64) {&#10;        data = ctx-&gt;_body(ctx, data, size &amp; ~(unsigned long)0x3f);&#10;        size &amp;= 0x3f;&#10;    }&#10;&#10;    memcpy(ctx-&gt;buffer, data, size);&#10;}&#10;&#10;inline void _picohash_md5_final(_picohash_md5_ctx_t *ctx, void *_digest)&#10;{&#10;    unsigned char *digest = (unsigned char *)_digest;&#10;    unsigned long used, free;&#10;&#10;    used = ctx-&gt;lo &amp; 0x3f;&#10;&#10;    ctx-&gt;buffer[used++] = 0x80;&#10;&#10;    free = 64 - used;&#10;&#10;    if (free &lt; 8) {&#10;        memset(&amp;ctx-&gt;buffer[used], 0, free);&#10;        ctx-&gt;_body(ctx, ctx-&gt;buffer, 64);&#10;        used = 0;&#10;        free = 64;&#10;    }&#10;&#10;    memset(&amp;ctx-&gt;buffer[used], 0, free - 8);&#10;&#10;    ctx-&gt;lo &lt;&lt;= 3;&#10;    ctx-&gt;buffer[56] = ctx-&gt;lo;&#10;    ctx-&gt;buffer[57] = ctx-&gt;lo &gt;&gt; 8;&#10;    ctx-&gt;buffer[58] = ctx-&gt;lo &gt;&gt; 16;&#10;    ctx-&gt;buffer[59] = ctx-&gt;lo &gt;&gt; 24;&#10;    ctx-&gt;buffer[60] = ctx-&gt;hi;&#10;    ctx-&gt;buffer[61] = ctx-&gt;hi &gt;&gt; 8;&#10;    ctx-&gt;buffer[62] = ctx-&gt;hi &gt;&gt; 16;&#10;    ctx-&gt;buffer[63] = ctx-&gt;hi &gt;&gt; 24;&#10;&#10;    ctx-&gt;_body(ctx, ctx-&gt;buffer, 64);&#10;&#10;    digest[0] = ctx-&gt;a;&#10;    digest[1] = ctx-&gt;a &gt;&gt; 8;&#10;    digest[2] = ctx-&gt;a &gt;&gt; 16;&#10;    digest[3] = ctx-&gt;a &gt;&gt; 24;&#10;    digest[4] = ctx-&gt;b;&#10;    digest[5] = ctx-&gt;b &gt;&gt; 8;&#10;    digest[6] = ctx-&gt;b &gt;&gt; 16;&#10;    digest[7] = ctx-&gt;b &gt;&gt; 24;&#10;    digest[8] = ctx-&gt;c;&#10;    digest[9] = ctx-&gt;c &gt;&gt; 8;&#10;    digest[10] = ctx-&gt;c &gt;&gt; 16;&#10;    digest[11] = ctx-&gt;c &gt;&gt; 24;&#10;    digest[12] = ctx-&gt;d;&#10;    digest[13] = ctx-&gt;d &gt;&gt; 8;&#10;    digest[14] = ctx-&gt;d &gt;&gt; 16;&#10;    digest[15] = ctx-&gt;d &gt;&gt; 24;&#10;&#10;    memset(ctx, 0, sizeof(*ctx));&#10;}&#10;&#10;#define _PICOHASH_SHA1_K0 0x5a827999&#10;#define _PICOHASH_SHA1_K20 0x6ed9eba1&#10;#define _PICOHASH_SHA1_K40 0x8f1bbcdc&#10;#define _PICOHASH_SHA1_K60 0xca62c1d6&#10;&#10;static inline uint32_t _picohash_sha1_rol32(uint32_t number, uint8_t bits)&#10;{&#10;    return ((number &lt;&lt; bits) | (number &gt;&gt; (32 - bits)));&#10;}&#10;&#10;static inline void _picohash_sha1_hash_block(_picohash_sha1_ctx_t *s)&#10;{&#10;    uint8_t i;&#10;    uint32_t a, b, c, d, e, t;&#10;&#10;    a = s-&gt;state[0];&#10;    b = s-&gt;state[1];&#10;    c = s-&gt;state[2];&#10;    d = s-&gt;state[3];&#10;    e = s-&gt;state[4];&#10;    for (i = 0; i &lt; 80; i++) {&#10;        if (i &gt;= 16) {&#10;            t = s-&gt;buffer[(i + 13) &amp; 15] ^ s-&gt;buffer[(i + 8) &amp; 15] ^ s-&gt;buffer[(i + 2) &amp; 15] ^ s-&gt;buffer[i &amp; 15];&#10;            s-&gt;buffer[i &amp; 15] = _picohash_sha1_rol32(t, 1);&#10;        }&#10;        if (i &lt; 20) {&#10;            t = (d ^ (b &amp; (c ^ d))) + _PICOHASH_SHA1_K0;&#10;        } else if (i &lt; 40) {&#10;            t = (b ^ c ^ d) + _PICOHASH_SHA1_K20;&#10;        } else if (i &lt; 60) {&#10;            t = ((b &amp; c) | (d &amp; (b | c))) + _PICOHASH_SHA1_K40;&#10;        } else {&#10;            t = (b ^ c ^ d) + _PICOHASH_SHA1_K60;&#10;        }&#10;        t += _picohash_sha1_rol32(a, 5) + e + s-&gt;buffer[i &amp; 15];&#10;        e = d;&#10;        d = c;&#10;        c = _picohash_sha1_rol32(b, 30);&#10;        b = a;&#10;        a = t;&#10;    }&#10;    s-&gt;state[0] += a;&#10;    s-&gt;state[1] += b;&#10;    s-&gt;state[2] += c;&#10;    s-&gt;state[3] += d;&#10;    s-&gt;state[4] += e;&#10;}&#10;&#10;static inline void _picohash_sha1_add_uncounted(_picohash_sha1_ctx_t *s, uint8_t data)&#10;{&#10;    uint8_t *const b = (uint8_t *)s-&gt;buffer;&#10;#ifdef _PICOHASH_BIG_ENDIAN&#10;    b[s-&gt;bufferOffset] = data;&#10;#else&#10;    b[s-&gt;bufferOffset ^ 3] = data;&#10;#endif&#10;    s-&gt;bufferOffset++;&#10;    if (s-&gt;bufferOffset == PICOHASH_SHA1_BLOCK_LENGTH) {&#10;        _picohash_sha1_hash_block(s);&#10;        s-&gt;bufferOffset = 0;&#10;    }&#10;}&#10;&#10;inline void _picohash_sha1_init(_picohash_sha1_ctx_t *s)&#10;{&#10;    s-&gt;state[0] = 0x67452301;&#10;    s-&gt;state[1] = 0xefcdab89;&#10;    s-&gt;state[2] = 0x98badcfe;&#10;    s-&gt;state[3] = 0x10325476;&#10;    s-&gt;state[4] = 0xc3d2e1f0;&#10;    s-&gt;byteCount = 0;&#10;    s-&gt;bufferOffset = 0;&#10;}&#10;&#10;inline void _picohash_sha1_update(_picohash_sha1_ctx_t *s, const void *_data, size_t len)&#10;{&#10;    const uint8_t *data = _data;&#10;    for (; len != 0; --len) {&#10;        ++s-&gt;byteCount;&#10;        _picohash_sha1_add_uncounted(s, *data++);&#10;    }&#10;}&#10;&#10;inline void _picohash_sha1_final(_picohash_sha1_ctx_t *s, void *digest)&#10;{&#10;    // Pad with 0x80 followed by 0x00 until the end of the block&#10;    _picohash_sha1_add_uncounted(s, 0x80);&#10;    while (s-&gt;bufferOffset != 56)&#10;        _picohash_sha1_add_uncounted(s, 0x00);&#10;&#10;    // Append length in the last 8 bytes&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 53); // Shifting to multiply by 8&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 45); // as SHA-1 supports bitstreams as well as&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 37); // byte.&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 29);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 21);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 13);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &gt;&gt; 5);&#10;    _picohash_sha1_add_uncounted(s, s-&gt;byteCount &lt;&lt; 3);&#10;&#10;#ifndef SHA_BIG_ENDIAN&#10;    { // Swap byte order back&#10;        int i;&#10;        for (i = 0; i &lt; 5; i++) {&#10;            s-&gt;state[i] = (((s-&gt;state[i]) &lt;&lt; 24) &amp; 0xff000000) | (((s-&gt;state[i]) &lt;&lt; 8) &amp; 0x00ff0000) |&#10;                          (((s-&gt;state[i]) &gt;&gt; 8) &amp; 0x0000ff00) | (((s-&gt;state[i]) &gt;&gt; 24) &amp; 0x000000ff);&#10;        }&#10;    }&#10;#endif&#10;&#10;    memcpy(digest, s-&gt;state, sizeof(s-&gt;state));&#10;}&#10;&#10;#define _picohash_sha256_ch(x, y, z) (z ^ (x &amp; (y ^ z)))&#10;#define _picohash_sha256_maj(x, y, z) (((x | y) &amp; z) | (x &amp; y))&#10;#define _picohash_sha256_s(x, y)                                                                                                   \&#10;    (((((uint32_t)(x)&amp;0xFFFFFFFFUL) &gt;&gt; (uint32_t)((y)&amp;31)) | ((uint32_t)(x) &lt;&lt; (uint32_t)(32 - ((y)&amp;31)))) &amp; 0xFFFFFFFFUL)&#10;#define _picohash_sha256_r(x, n) (((x)&amp;0xFFFFFFFFUL) &gt;&gt; (n))&#10;#define _picohash_sha256_sigma0(x) (_picohash_sha256_s(x, 2) ^ _picohash_sha256_s(x, 13) ^ _picohash_sha256_s(x, 22))&#10;#define _picohash_sha256_sigma1(x) (_picohash_sha256_s(x, 6) ^ _picohash_sha256_s(x, 11) ^ _picohash_sha256_s(x, 25))&#10;#define _picohash_sha256_gamma0(x) (_picohash_sha256_s(x, 7) ^ _picohash_sha256_s(x, 18) ^ _picohash_sha256_r(x, 3))&#10;#define _picohash_sha256_gamma1(x) (_picohash_sha256_s(x, 17) ^ _picohash_sha256_s(x, 19) ^ _picohash_sha256_r(x, 10))&#10;#define _picohash_sha256_rnd(a, b, c, d, e, f, g, h, i)                                                                            \&#10;    t0 = h + _picohash_sha256_sigma1(e) + _picohash_sha256_ch(e, f, g) + K[i] + W[i];                                              \&#10;    t1 = _picohash_sha256_sigma0(a) + _picohash_sha256_maj(a, b, c);                                                               \&#10;    d += t0;                                                                                                                       \&#10;    h = t0 + t1;&#10;&#10;static inline void _picohash_sha256_compress(_picohash_sha256_ctx_t *ctx, unsigned char *buf)&#10;{&#10;    static const uint32_t K[64] = {&#10;        0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,&#10;        0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,&#10;        0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL, 0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,&#10;        0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,&#10;        0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,&#10;        0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,&#10;        0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,&#10;        0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL, 0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL};&#10;    uint32_t S[8], W[64], t, t0, t1;&#10;    int i;&#10;&#10;    /* copy state into S */&#10;    for (i = 0; i &lt; 8; i++)&#10;        S[i] = ctx-&gt;state[i];&#10;&#10;    /* copy the state into 512-bits into W[0..15] */&#10;    for (i = 0; i &lt; 16; i++)&#10;        W[i] =&#10;            (uint32_t)buf[4 * i] &lt;&lt; 24 | (uint32_t)buf[4 * i + 1] &lt;&lt; 16 | (uint32_t)buf[4 * i + 2] &lt;&lt; 8 | (uint32_t)buf[4 * i + 3];&#10;&#10;    /* fill W[16..63] */&#10;    for (i = 16; i &lt; 64; i++)&#10;        W[i] = _picohash_sha256_gamma1(W[i - 2]) + W[i - 7] + _picohash_sha256_gamma0(W[i - 15]) + W[i - 16];&#10;&#10;    /* Compress */&#10;    for (i = 0; i &lt; 64; ++i) {&#10;        _picohash_sha256_rnd(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);&#10;        t = S[7];&#10;        S[7] = S[6];&#10;        S[6] = S[5];&#10;        S[5] = S[4];&#10;        S[4] = S[3];&#10;        S[3] = S[2];&#10;        S[2] = S[1];&#10;        S[1] = S[0];&#10;        S[0] = t;&#10;    }&#10;&#10;    /* feedback */&#10;    for (i = 0; i &lt; 8; i++)&#10;        ctx-&gt;state[i] = ctx-&gt;state[i] + S[i];&#10;}&#10;&#10;static inline void _picohash_sha256_do_final(_picohash_sha256_ctx_t *ctx, void *digest, size_t len)&#10;{&#10;    unsigned char *out = digest;&#10;    size_t i;&#10;&#10;    /* increase the length of the message */&#10;    ctx-&gt;length += ctx-&gt;curlen * 8;&#10;&#10;    /* append the '1' bit */&#10;    ctx-&gt;buf[ctx-&gt;curlen++] = (unsigned char)0x80;&#10;&#10;    /* if the length is currently above 56 bytes we append zeros&#10;     * then compress.  Then we can fall back to padding zeros and length&#10;     * encoding like normal.&#10;     */&#10;    if (ctx-&gt;curlen &gt; 56) {&#10;        while (ctx-&gt;curlen &lt; 64) {&#10;            ctx-&gt;buf[ctx-&gt;curlen++] = (unsigned char)0;&#10;        }&#10;        _picohash_sha256_compress(ctx, ctx-&gt;buf);&#10;        ctx-&gt;curlen = 0;&#10;    }&#10;&#10;    /* pad upto 56 bytes of zeroes */&#10;    while (ctx-&gt;curlen &lt; 56) {&#10;        ctx-&gt;buf[ctx-&gt;curlen++] = (unsigned char)0;&#10;    }&#10;&#10;    /* store length */&#10;    for (i = 0; i != 8; ++i)&#10;        ctx-&gt;buf[56 + i] = ctx-&gt;length &gt;&gt; (56 - 8 * i);&#10;    _picohash_sha256_compress(ctx, ctx-&gt;buf);&#10;&#10;    /* copy output */&#10;    for (i = 0; i != len / 4; ++i) {&#10;        out[i * 4] = ctx-&gt;state[i] &gt;&gt; 24;&#10;        out[i * 4 + 1] = ctx-&gt;state[i] &gt;&gt; 16;&#10;        out[i * 4 + 2] = ctx-&gt;state[i] &gt;&gt; 8;&#10;        out[i * 4 + 3] = ctx-&gt;state[i];&#10;    }&#10;}&#10;&#10;inline void _picohash_sha256_init(_picohash_sha256_ctx_t *ctx)&#10;{&#10;    ctx-&gt;curlen = 0;&#10;    ctx-&gt;length = 0;&#10;    ctx-&gt;state[0] = 0x6A09E667UL;&#10;    ctx-&gt;state[1] = 0xBB67AE85UL;&#10;    ctx-&gt;state[2] = 0x3C6EF372UL;&#10;    ctx-&gt;state[3] = 0xA54FF53AUL;&#10;    ctx-&gt;state[4] = 0x510E527FUL;&#10;    ctx-&gt;state[5] = 0x9B05688CUL;&#10;    ctx-&gt;state[6] = 0x1F83D9ABUL;&#10;    ctx-&gt;state[7] = 0x5BE0CD19UL;&#10;}&#10;&#10;inline void _picohash_sha256_update(_picohash_sha256_ctx_t *ctx, const void *data, size_t len)&#10;{&#10;    const unsigned char *in = data;&#10;    size_t n;&#10;&#10;    while (len &gt; 0) {&#10;        if (ctx-&gt;curlen == 0 &amp;&amp; len &gt;= PICOHASH_SHA256_BLOCK_LENGTH) {&#10;            _picohash_sha256_compress(ctx, (unsigned char *)in);&#10;            ctx-&gt;length += PICOHASH_SHA256_BLOCK_LENGTH * 8;&#10;            in += PICOHASH_SHA256_BLOCK_LENGTH;&#10;            len -= PICOHASH_SHA256_BLOCK_LENGTH;&#10;        } else {&#10;            n = PICOHASH_SHA256_BLOCK_LENGTH - ctx-&gt;curlen;&#10;            if (n &gt; len)&#10;                n = len;&#10;            memcpy(ctx-&gt;buf + ctx-&gt;curlen, in, (size_t)n);&#10;            ctx-&gt;curlen += n;&#10;            in += n;&#10;            len -= n;&#10;            if (ctx-&gt;curlen == 64) {&#10;                _picohash_sha256_compress(ctx, ctx-&gt;buf);&#10;                ctx-&gt;length += 8 * PICOHASH_SHA256_BLOCK_LENGTH;&#10;                ctx-&gt;curlen = 0;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;inline void _picohash_sha256_final(_picohash_sha256_ctx_t *ctx, void *digest)&#10;{&#10;    _picohash_sha256_do_final(ctx, digest, PICOHASH_SHA256_DIGEST_LENGTH);&#10;}&#10;&#10;inline void _picohash_sha224_init(_picohash_sha256_ctx_t *ctx)&#10;{&#10;    ctx-&gt;curlen = 0;&#10;    ctx-&gt;length = 0;&#10;    ctx-&gt;state[0] = 0xc1059ed8UL;&#10;    ctx-&gt;state[1] = 0x367cd507UL;&#10;    ctx-&gt;state[2] = 0x3070dd17UL;&#10;    ctx-&gt;state[3] = 0xf70e5939UL;&#10;    ctx-&gt;state[4] = 0xffc00b31UL;&#10;    ctx-&gt;state[5] = 0x68581511UL;&#10;    ctx-&gt;state[6] = 0x64f98fa7UL;&#10;    ctx-&gt;state[7] = 0xbefa4fa4UL;&#10;}&#10;&#10;inline void _picohash_sha224_final(_picohash_sha256_ctx_t *ctx, void *digest)&#10;{&#10;    _picohash_sha256_do_final(ctx, digest, PICOHASH_SHA224_DIGEST_LENGTH);&#10;}&#10;&#10;inline void picohash_init_md5(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_MD5_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_MD5_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_md5_init;&#10;    ctx-&gt;_update = (void *)_picohash_md5_update;&#10;    ctx-&gt;_final = (void *)_picohash_md5_final;&#10;&#10;    _picohash_md5_init(&amp;ctx-&gt;_md5);&#10;}&#10;&#10;inline void picohash_init_sha1(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_SHA1_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_SHA1_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_sha1_init;&#10;    ctx-&gt;_update = (void *)_picohash_sha1_update;&#10;    ctx-&gt;_final = (void *)_picohash_sha1_final;&#10;    _picohash_sha1_init(&amp;ctx-&gt;_sha1);&#10;}&#10;&#10;inline void picohash_init_sha224(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_SHA224_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_SHA224_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_sha224_init;&#10;    ctx-&gt;_update = (void *)_picohash_sha256_update;&#10;    ctx-&gt;_final = (void *)_picohash_sha224_final;&#10;    _picohash_sha224_init(&amp;ctx-&gt;_sha256);&#10;}&#10;&#10;inline void picohash_init_sha256(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;block_length = PICOHASH_SHA256_BLOCK_LENGTH;&#10;    ctx-&gt;digest_length = PICOHASH_SHA256_DIGEST_LENGTH;&#10;    ctx-&gt;_reset = (void *)_picohash_sha256_init;&#10;    ctx-&gt;_update = (void *)_picohash_sha256_update;&#10;    ctx-&gt;_final = (void *)_picohash_sha256_final;&#10;    _picohash_sha256_init(&amp;ctx-&gt;_sha256);&#10;}&#10;&#10;inline void picohash_update(picohash_ctx_t *ctx, const void *input, size_t len)&#10;{&#10;    ctx-&gt;_update(ctx, input, len);&#10;}&#10;&#10;inline void picohash_final(picohash_ctx_t *ctx, void *digest)&#10;{&#10;    ctx-&gt;_final(ctx, digest);&#10;}&#10;&#10;inline void picohash_reset(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;_reset(ctx);&#10;}&#10;&#10;static inline void _picohash_hmac_apply_key(picohash_ctx_t *ctx, unsigned char delta)&#10;{&#10;    size_t i;&#10;    for (i = 0; i != ctx-&gt;block_length; ++i)&#10;        ctx-&gt;_hmac.key[i] ^= delta;&#10;    picohash_update(ctx, ctx-&gt;_hmac.key, ctx-&gt;block_length);&#10;    for (i = 0; i != ctx-&gt;block_length; ++i)&#10;        ctx-&gt;_hmac.key[i] ^= delta;&#10;}&#10;&#10;static void _picohash_hmac_final(picohash_ctx_t *ctx, void *digest)&#10;{&#10;    unsigned char inner_digest[PICOHASH_MAX_DIGEST_LENGTH];&#10;&#10;    ctx-&gt;_hmac.hash_final(ctx, inner_digest);&#10;&#10;    ctx-&gt;_hmac.hash_reset(ctx);&#10;    _picohash_hmac_apply_key(ctx, 0x5c);&#10;    picohash_update(ctx, inner_digest, ctx-&gt;digest_length);&#10;    memset(inner_digest, 0, ctx-&gt;digest_length);&#10;&#10;    ctx-&gt;_hmac.hash_final(ctx, digest);&#10;}&#10;&#10;static inline void _picohash_hmac_reset(picohash_ctx_t *ctx)&#10;{&#10;    ctx-&gt;_hmac.hash_reset(ctx);&#10;    _picohash_hmac_apply_key(ctx, 0x36);&#10;}&#10;&#10;inline void picohash_init_hmac(picohash_ctx_t *ctx, void (*initf)(picohash_ctx_t *), const void *key, size_t key_len)&#10;{&#10;    initf(ctx);&#10;&#10;    memset(ctx-&gt;_hmac.key, 0, ctx-&gt;block_length);&#10;    if (key_len &gt; ctx-&gt;block_length) {&#10;        /* hash the key if it is too long */&#10;        picohash_update(ctx, key, key_len);&#10;        picohash_final(ctx, ctx-&gt;_hmac.key);&#10;        ctx-&gt;_hmac.hash_reset(ctx);&#10;    } else {&#10;        memcpy(ctx-&gt;_hmac.key, key, key_len);&#10;    }&#10;&#10;    /* replace reset and final function */&#10;    ctx-&gt;_hmac.hash_reset = ctx-&gt;_reset;&#10;    ctx-&gt;_hmac.hash_final = ctx-&gt;_final;&#10;    ctx-&gt;_reset = (void *)_picohash_hmac_reset;&#10;    ctx-&gt;_final = (void *)_picohash_hmac_final;&#10;&#10;    /* start calculating the inner hash */&#10;    _picohash_hmac_apply_key(ctx, 0x36);&#10;}&#10;&#10;#endif&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/portal/engine/strings/md5_hash.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/portal/engine/strings/md5_hash.h" />
              <option name="originalContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;string&gt;&#10;#include &lt;portal/core/common.h&gt;&#10;&#10;#include &quot;hash/picohash.h&quot;&#10;#include &quot;hash/compile_time/compile_time_md5.hpp&quot;&#10;&#10;namespace portal::hash&#10;{&#10;&#10;&#10;template &lt;size_t n&gt;&#10;consteval uint128_t md5(const char (&amp;data)[n])&#10;{&#10;    auto hash = CT_MD5(data);&#10;&#10;    // MD5 produces 4 x 32-bit values, combine them into a 128-bit value&#10;    // Note: MD5 is typically represented in little-endian byte order&#10;    const uint64_t lo = (static_cast&lt;uint64_t&gt;(hash[1]) &lt;&lt; 32) | hash[0];&#10;    const uint64_t hi = (static_cast&lt;uint64_t&gt;(hash[3]) &lt;&lt; 32) | hash[2];&#10;&#10;    return uint128_t{lo, hi};&#10;}&#10;&#10;// Runtime version for dynamic strings&#10;inline uint128_t md5(const char* data, size_t length)&#10;{&#10;    picohash_ctx_t ctx;&#10;    char digest[PICOHASH_MD5_DIGEST_LENGTH];&#10;&#10;    picohash_init_md5(&amp;ctx);&#10;    picohash_update(&amp;ctx, data, length);&#10;    picohash_final(&amp;ctx, digest);&#10;&#10;    // Convert 16 bytes to uint128_t (digest is in little-endian byte order)&#10;    uint64_t lo = 0, hi = 0;&#10;&#10;    // Build lower 64 bits from bytes 0-7&#10;    for (int i = 0; i &lt; 8; ++i) {&#10;        lo |= (static_cast&lt;uint64_t&gt;(static_cast&lt;unsigned char&gt;(digest[i])) &lt;&lt; (i * 8));&#10;    }&#10;&#10;    // Build upper 64 bits from bytes 8-15&#10;    for (int i = 0; i &lt; 8; ++i) {&#10;        hi |= (static_cast&lt;uint64_t&gt;(static_cast&lt;unsigned char&gt;(digest[i + 8])) &lt;&lt; (i * 8));&#10;    }&#10;&#10;    return uint128_t{lo, hi};&#10;}&#10;&#10;// Convenience overload for std::string&#10;inline uint128_t md5(const std::string&amp; str)&#10;{&#10;    return md5(str.c_str(), str.length());&#10;}&#10;&#10;namespace literals&#10;{&#10;    template &lt;std::size_t N&gt;&#10;    struct MD5String&#10;    {&#10;        uint128_t hashed{};&#10;&#10;        consteval explicit MD5String(const char (&amp;str)[N])&#10;        {&#10;            hashed = md5&lt;N&gt;(str);&#10;        }&#10;    };&#10;&#10;    template &lt;MD5String T&gt;&#10;    consteval auto operator &quot;&quot;_md5()&#10;    {&#10;        return T.hashed;&#10;    }&#10;}&#10;&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;string&gt;&#10;#include &lt;portal/core/common.h&gt;&#10;&#10;#include &quot;hash/picohash.h&quot;&#10;#include &quot;hash/compile_time/compile_time_md5.hpp&quot;&#10;&#10;namespace portal::hash&#10;{&#10;&#10;&#10;template &lt;size_t n&gt;&#10;consteval uint128_t md5(const char (&amp;data)[n])&#10;{&#10;    auto hash = CT_MD5(data);&#10;&#10;    // MD5 produces 4 x 32-bit values, combine them into a 128-bit value&#10;    // Note: MD5 is typically represented in little-endian byte order&#10;    const uint64_t lo = (static_cast&lt;uint64_t&gt;(hash[1]) &lt;&lt; 32) | hash[0];&#10;    const uint64_t hi = (static_cast&lt;uint64_t&gt;(hash[3]) &lt;&lt; 32) | hash[2];&#10;&#10;    return uint128_t{lo, hi};&#10;}&#10;&#10;// Runtime version for dynamic strings&#10;inline uint128_t md5(const char* data, size_t length)&#10;{&#10;    picohash_ctx_t ctx;&#10;    char digest[PICOHASH_MD5_DIGEST_LENGTH];&#10;&#10;    picohash_init_md5(&amp;ctx);&#10;    picohash_update(&amp;ctx, data, length);&#10;    picohash_final(&amp;ctx, digest);&#10;&#10;    // Convert 16 bytes to uint128_t (digest is in little-endian byte order)&#10;    uint64_t lo = 0, hi = 0;&#10;&#10;    // Build lower 64 bits from bytes 0-7&#10;    for (int i = 0; i &lt; 8; ++i) {&#10;        lo |= (static_cast&lt;uint64_t&gt;(static_cast&lt;unsigned char&gt;(digest[i])) &lt;&lt; (i * 8));&#10;    }&#10;&#10;    // Build upper 64 bits from bytes 8-15&#10;    for (int i = 0; i &lt; 8; ++i) {&#10;        hi |= (static_cast&lt;uint64_t&gt;(static_cast&lt;unsigned char&gt;(digest[i + 8])) &lt;&lt; (i * 8));&#10;    }&#10;&#10;    return uint128_t{lo, hi};&#10;}&#10;&#10;// Convenience overload for std::string&#10;inline uint128_t md5(const std::string&amp; str)&#10;{&#10;    return md5(str.c_str(), str.length());&#10;}&#10;&#10;namespace literals&#10;{&#10;    template &lt;std::size_t N&gt;&#10;    struct MD5String&#10;    {&#10;        uint128_t hashed{};&#10;&#10;        consteval explicit MD5String(const char (&amp;str)[N])&#10;        {&#10;            hashed = md5&lt;N&gt;(str);&#10;        }&#10;    };&#10;&#10;    template &lt;MD5String T&gt;&#10;    consteval auto operator &quot;&quot;_md5()&#10;    {&#10;        return T.hashed;&#10;    }&#10;}&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/tests/resources/loader/loader_factory_tests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/tests/resources/loader/loader_factory_tests.cpp" />
              <option name="originalContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;portal/engine/resources/loader/loader_factory.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/engine/resources/gpu_context.h&quot;&#10;#include &quot;portal/engine/renderer/allocated_image.h&quot;&#10;&#10;using namespace portal::resources;&#10;using namespace portal;&#10;&#10;static vk::raii::Device g_device = nullptr;&#10;static vk::raii::CommandBuffer g_command_buffer = nullptr;&#10;static vk::raii::Queue g_queue = nullptr;&#10;&#10;// Mock GpuContext for testing&#10;class MockGpuContext : public GpuContext&#10;{&#10;public:&#10;    // Create mock constructor that calls the real constructor with mock objects&#10;    MockGpuContext() : GpuContext(g_device, g_command_buffer,g_queue) {}&#10;&#10;    MOCK_METHOD(vulkan::AllocatedImage, create_image, (void* data, vulkan::ImageBuilder image_builder), (const, override));&#10;};&#10;&#10;class LoaderFactoryTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;&#10;        // Set up default mock behavior for create_image&#10;        EXPECT_CALL(*gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, vulkan::ImageBuilder) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;&#10;        factory.initialize(gpu_context);&#10;        texture_resource = Ref&lt;Texture&gt;::create(STRING_ID(&quot;test_texture&quot;));&#10;        regular_resource = Ref&lt;Resource&gt;::create(STRING_ID(&quot;test_resource&quot;));&#10;    }&#10;&#10;    void TearDown() override&#10;    {&#10;        factory.shutdown();&#10;    }&#10;&#10;    LoaderFactory factory;&#10;    std::shared_ptr&lt;MockGpuContext&gt; gpu_context;&#10;    Ref&lt;Texture&gt; texture_resource;&#10;    Ref&lt;Resource&gt; regular_resource;&#10;};&#10;&#10;TEST_F(LoaderFactoryTest, InitializesCorrectly)&#10;{&#10;    LoaderFactory new_factory;&#10;    auto new_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;&#10;    // Set up mock behavior&#10;    EXPECT_CALL(*new_gpu_context, create_image(testing::_, testing::_))&#10;        .WillRepeatedly(testing::Invoke([](void*, vulkan::ImageBuilder) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    // Factory should initialize without throwing&#10;    EXPECT_NO_THROW(new_factory.initialize(new_gpu_context));&#10;    new_factory.shutdown();&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ShutsDownCorrectly)&#10;{&#10;    EXPECT_NO_THROW(factory.shutdown());&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsTextureLoaderForTexture)&#10;{&#10;    ResourceLoader&amp; loader = factory.get(texture_resource);&#10;&#10;    // Should not be null&#10;    EXPECT_NE(nullptr, &amp;loader);&#10;&#10;    // Mock the create_image call that will be made during default texture creation&#10;    EXPECT_CALL(*gpu_context, create_image(testing::_, testing::_))&#10;        .Times(testing::AtLeast(1))&#10;        .WillRepeatedly(testing::Invoke([](void*, vulkan::ImageBuilder) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    // Should be able to call methods without crashing&#10;    EXPECT_NO_THROW(loader.load_default(texture_resource));&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsStubLoaderForUnknownType)&#10;{&#10;    ResourceLoader&amp; loader = factory.get(regular_resource);&#10;&#10;    // Should not be null - should return StubLoader&#10;    EXPECT_NE(nullptr, &amp;loader);&#10;&#10;    // Should be able to call methods without crashing (StubLoader does nothing)&#10;    EXPECT_NO_THROW(loader.load_default(regular_resource));&#10;&#10;    // Resource should remain in Empty state since StubLoader does nothing&#10;    EXPECT_EQ(ResourceState::Empty, regular_resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsSameLoaderInstanceForSameType)&#10;{&#10;    auto texture1 = Ref&lt;Texture&gt;::create(STRING_ID(&quot;texture1&quot;));&#10;    auto texture2 = Ref&lt;Texture&gt;::create(STRING_ID(&quot;texture2&quot;));&#10;&#10;    ResourceLoader&amp; loader1 = factory.get(texture1);&#10;    ResourceLoader&amp; loader2 = factory.get(texture2);&#10;&#10;    // Should return the same loader instance for the same resource type&#10;    EXPECT_EQ(&amp;loader1, &amp;loader2);&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, HandlesNullResource)&#10;{&#10;    Ref&lt;Resource&gt; null_resource = nullptr;&#10;&#10;    // Should handle null resource gracefully by returning StubLoader&#10;    EXPECT_NO_THROW(factory.get(null_resource));&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, DifferentResourceTypesReturnDifferentLoaders)&#10;{&#10;    ResourceLoader&amp; texture_loader = factory.get(texture_resource);&#10;    ResourceLoader&amp; stub_loader = factory.get(regular_resource);&#10;&#10;    // Different resource types should return different loader instances&#10;    EXPECT_NE(&amp;texture_loader, &amp;stub_loader);&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, CanReinitialize)&#10;{&#10;    factory.shutdown();&#10;&#10;    // Set up mock behavior for reinitialization&#10;    EXPECT_CALL(*gpu_context, create_image(testing::_, testing::_))&#10;        .WillRepeatedly(testing::Invoke([](void*, vulkan::ImageBuilder) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    EXPECT_NO_THROW(factory.initialize(gpu_context));&#10;&#10;    // Should still work after reinitialization&#10;    ResourceLoader&amp; loader = factory.get(texture_resource);&#10;    EXPECT_NE(nullptr, &amp;loader);&#10;}&#10;&#10;// Test with custom resource type that doesn't have a loader&#10;class CustomResource : public Resource&#10;{&#10;public:&#10;    explicit CustomResource(const StringId&amp; id) : Resource(id) {}&#10;};&#10;&#10;TEST_F(LoaderFactoryTest, HandlesCustomResourceType)&#10;{&#10;    auto custom_resource = Ref&lt;CustomResource&gt;::create(STRING_ID(&quot;custom&quot;));&#10;&#10;    ResourceLoader&amp; loader = factory.get(custom_resource);&#10;&#10;    // Should return StubLoader for unknown resource types&#10;    EXPECT_NE(nullptr, &amp;loader);&#10;    EXPECT_NO_THROW(loader.load_default(custom_resource));&#10;&#10;    // Custom resource should remain in Empty state&#10;    EXPECT_EQ(ResourceState::Empty, custom_resource-&gt;get_state());&#10;}" />
              <option name="updatedContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;portal/engine/resources/loader/loader_factory.h&quot;&#10;#include &quot;portal/engine/resources/source/resource_source.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/engine/resources/gpu_context.h&quot;&#10;#include &quot;portal/engine/renderer/allocated_image.h&quot;&#10;&#10;using namespace portal::resources;&#10;using namespace portal;&#10;&#10;static vk::raii::Device g_device = nullptr;&#10;static vk::raii::CommandBuffer g_command_buffer = nullptr;&#10;static vk::raii::Queue g_queue = nullptr;&#10;&#10;// Mock GpuContext for testing&#10;class MockGpuContext : public GpuContext&#10;{&#10;public:&#10;    // Create mock constructor that calls the real constructor with mock objects&#10;    MockGpuContext() : GpuContext(g_device, g_command_buffer, g_queue) {}&#10;&#10;    MOCK_METHOD(vulkan::AllocatedImage, create_image, (void* data, vulkan::ImageBuilder image_builder), (const, override));&#10;};&#10;&#10;class LoaderFactoryTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;&#10;        // Set up default mock behavior for create_image&#10;        EXPECT_CALL(*gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, vulkan::ImageBuilder) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;&#10;        factory.initialize(gpu_context);&#10;        texture_resource = Ref&lt;Texture&gt;::create(STRING_ID(&quot;test_texture&quot;));&#10;        regular_resource = Ref&lt;Resource&gt;::create(STRING_ID(&quot;test_resource&quot;));&#10;    }&#10;&#10;    LoaderFactory factory;&#10;    std::shared_ptr&lt;MockGpuContext&gt; gpu_context;&#10;    Ref&lt;Texture&gt; texture_resource;&#10;    Ref&lt;Resource&gt; regular_resource;&#10;};&#10;&#10;TEST_F(LoaderFactoryTest, InitializesCorrectly)&#10;{&#10;    LoaderFactory new_factory;&#10;    auto new_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;&#10;    // Set up mock behavior&#10;    EXPECT_CALL(*new_gpu_context, create_image(testing::_, testing::_))&#10;        .WillRepeatedly(testing::Invoke([](void*, vulkan::ImageBuilder) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    // Factory should initialize without throwing&#10;    EXPECT_NO_THROW(new_factory.initialize(new_gpu_context));&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsImageLoaderForTextureWithImageFormat)&#10;{&#10;    SourceMetadata metadata{&#10;        STRING_ID(&quot;test_texture&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Image&#10;    };&#10;&#10;    auto loader = factory.get(metadata);&#10;&#10;    // Should not be null&#10;    EXPECT_NE(nullptr, loader);&#10;&#10;    // Should be able to call methods without crashing&#10;    EXPECT_NO_THROW(loader-&gt;load_default(texture_resource));&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsStubLoaderForUnknownType)&#10;{&#10;    SourceMetadata metadata{&#10;        STRING_ID(&quot;unknown_resource&quot;),&#10;        ResourceType::Unknown,&#10;        SourceFormat::Unknown&#10;    };&#10;&#10;    auto loader = factory.get(metadata);&#10;&#10;    // Should not be null (stub loader)&#10;    EXPECT_NE(nullptr, loader);&#10;&#10;    // Stub loader should handle calls gracefully&#10;    EXPECT_NO_THROW(loader-&gt;load_default(regular_resource));&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsStubLoaderForTextureWithUnknownFormat)&#10;{&#10;    SourceMetadata metadata{&#10;        STRING_ID(&quot;texture_unknown_format&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Unknown&#10;    };&#10;&#10;    auto loader = factory.get(metadata);&#10;&#10;    // Should return stub loader for unsupported format&#10;    EXPECT_NE(nullptr, loader);&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsStubLoaderForUnsupportedResourceTypes)&#10;{&#10;    // Test Material type&#10;    SourceMetadata material_metadata{&#10;        STRING_ID(&quot;material_resource&quot;),&#10;        ResourceType::Material,&#10;        SourceFormat::Material&#10;    };&#10;&#10;    auto material_loader = factory.get(material_metadata);&#10;    EXPECT_NE(nullptr, material_loader);&#10;&#10;    // Test Mesh type&#10;    SourceMetadata mesh_metadata{&#10;        STRING_ID(&quot;mesh_resource&quot;),&#10;        ResourceType::Mesh,&#10;        SourceFormat::Obj&#10;    };&#10;&#10;    auto mesh_loader = factory.get(mesh_metadata);&#10;    EXPECT_NE(nullptr, mesh_loader);&#10;&#10;    // Test Shader type&#10;    SourceMetadata shader_metadata{&#10;        STRING_ID(&quot;shader_resource&quot;),&#10;        ResourceType::Shader,&#10;        SourceFormat::Shader&#10;    };&#10;&#10;    auto shader_loader = factory.get(shader_metadata);&#10;    EXPECT_NE(nullptr, shader_loader);&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, ReturnsConsistentLoaderForSameMetadata)&#10;{&#10;    SourceMetadata metadata{&#10;        STRING_ID(&quot;consistent_texture&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Image&#10;    };&#10;&#10;    auto loader1 = factory.get(metadata);&#10;    auto loader2 = factory.get(metadata);&#10;&#10;    // Note: Depending on implementation, these might be the same instance or different instances&#10;    // Both should be valid&#10;    EXPECT_NE(nullptr, loader1);&#10;    EXPECT_NE(nullptr, loader2);&#10;}&#10;&#10;TEST_F(LoaderFactoryTest, HandlesMultipleTextureFormats)&#10;{&#10;    // Test Image format&#10;    SourceMetadata image_metadata{&#10;        STRING_ID(&quot;image_texture&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Image&#10;    };&#10;    auto image_loader = factory.get(image_metadata);&#10;    EXPECT_NE(nullptr, image_loader);&#10;&#10;    // Test Texture format (should return stub for now)&#10;    SourceMetadata texture_metadata{&#10;        STRING_ID(&quot;ktx_texture&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Texture&#10;    };&#10;    auto texture_loader = factory.get(texture_metadata);&#10;    EXPECT_NE(nullptr, texture_loader);&#10;&#10;    // Test Preprocessed format (should return stub for now)&#10;    SourceMetadata preprocessed_metadata{&#10;        STRING_ID(&quot;preprocessed_texture&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Preprocessed&#10;    };&#10;    auto preprocessed_loader = factory.get(preprocessed_metadata);&#10;    EXPECT_NE(nullptr, preprocessed_loader);&#10;}&#10;&#10;// Integration test&#10;TEST_F(LoaderFactoryTest, ImageLoaderCanLoadDefaultTexture)&#10;{&#10;    SourceMetadata metadata{&#10;        STRING_ID(&quot;integration_texture&quot;),&#10;        ResourceType::Texture,&#10;        SourceFormat::Image&#10;    };&#10;&#10;    auto loader = factory.get(metadata);&#10;    ASSERT_NE(nullptr, loader);&#10;&#10;    // Should be able to load default texture&#10;    loader-&gt;load_default(texture_resource);&#10;    EXPECT_EQ(ResourceState::Invalid, texture_resource-&gt;get_state());&#10;}&#10;&#10;class CustomResource : public Resource&#10;{&#10;public:&#10;    explicit CustomResource(StringId id) : Resource(id) {}&#10;    ResourceType get_type() const override { return ResourceType::Unknown; }&#10;};&#10;&#10;TEST_F(LoaderFactoryTest, StubLoaderHandlesCustomResourceTypes)&#10;{&#10;    SourceMetadata metadata{&#10;        STRING_ID(&quot;custom_resource&quot;),&#10;        ResourceType::Unknown,&#10;        SourceFormat::Unknown&#10;    };&#10;&#10;    auto loader = factory.get(metadata);&#10;    EXPECT_NE(nullptr, loader);&#10;&#10;    auto custom_resource = Ref&lt;CustomResource&gt;::create(STRING_ID(&quot;custom&quot;));&#10;    &#10;    // Stub loader should handle unknown resource types gracefully&#10;    EXPECT_NO_THROW(loader-&gt;load_default(custom_resource.as&lt;Resource&gt;()));&#10;    &#10;    // Should return empty signature&#10;    auto signatures = loader-&gt;get_signature();&#10;    EXPECT_TRUE(signatures.empty());&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/tests/resources/loader/loader_tests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/tests/resources/loader/loader_tests.cpp" />
              <option name="originalContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;&#10;#include &quot;portal/engine/resources/loader/loader.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/core/buffer.h&quot;&#10;&#10;using namespace portal::resources;&#10;using namespace portal;&#10;&#10;// Mock implementation for testing the abstract interface&#10;class MockResourceLoader : public ResourceLoader&#10;{&#10;public:&#10;    MOCK_METHOD(void, load, (Buffer&amp;&amp; data, std::shared_ptr&lt;Resource&gt; resource), (override));&#10;    MOCK_METHOD(void, load_default, (std::shared_ptr&lt;Resource&gt; resource), (const, override));&#10;};&#10;&#10;class ResourceLoaderTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        resource = std::make_shared&lt;Resource&gt;(STRING_ID(&quot;test_resource&quot;));&#10;        test_data = Buffer::copy(&quot;test data&quot;, 9);&#10;    }&#10;&#10;    MockResourceLoader mock_loader;&#10;    std::shared_ptr&lt;Resource&gt; resource;&#10;    Buffer test_data;&#10;};&#10;&#10;TEST_F(ResourceLoaderTest, CanInstantiateMock)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;MockResourceLoader&gt;();&#10;    ASSERT_NE(nullptr, loader);&#10;}&#10;&#10;TEST_F(ResourceLoaderTest, CanCallLoad)&#10;{&#10;    EXPECT_CALL(mock_loader, load(::testing::_, resource))&#10;        .Times(1);&#10;&#10;    mock_loader.load(std::move(test_data), resource);&#10;}&#10;&#10;TEST_F(ResourceLoaderTest, CanCallLoadDefault)&#10;{&#10;    EXPECT_CALL(mock_loader, load_default(resource))&#10;        .Times(1);&#10;&#10;    mock_loader.load_default(resource);&#10;}&#10;&#10;TEST_F(ResourceLoaderTest, PolymorphicBehavior)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;MockResourceLoader&gt;();&#10;    MockResourceLoader* mock_ptr = static_cast&lt;MockResourceLoader*&gt;(loader.get());&#10;&#10;    EXPECT_CALL(*mock_ptr, load(::testing::_, resource))&#10;        .Times(1);&#10;&#10;    Buffer data = Buffer::copy(&quot;polymorphic test&quot;, 16);&#10;    loader-&gt;load(std::move(data), resource);&#10;}&#10;&#10;// Test that the destructor is virtual (this should compile without issues)&#10;TEST_F(ResourceLoaderTest, VirtualDestructor)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;MockResourceLoader&gt;();&#10;    // If destructor wasn't virtual, this would be undefined behavior&#10;    loader.reset(); // Explicit destruction through base pointer&#10;    SUCCEED(); // If we get here, virtual destructor works correctly&#10;}&#10;&#10;// Tests for StubLoader&#10;class StubLoaderTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        resource = std::make_shared&lt;Resource&gt;(STRING_ID(&quot;test_resource&quot;));&#10;        texture_resource = std::make_shared&lt;Texture&gt;(STRING_ID(&quot;test_texture&quot;));&#10;        test_data = Buffer::copy(&quot;stub test data&quot;, 14);&#10;    }&#10;&#10;    StubLoader stub_loader;&#10;    std::shared_ptr&lt;Resource&gt; resource;&#10;    std::shared_ptr&lt;Texture&gt; texture_resource;&#10;    Buffer test_data;&#10;};&#10;&#10;TEST_F(StubLoaderTest, LoadDoesNothing)&#10;{&#10;    // StubLoader should not crash or throw when load is called&#10;    EXPECT_NO_THROW(stub_loader.load(std::move(test_data), resource));&#10;&#10;    // Resource state should remain unchanged&#10;    EXPECT_EQ(ResourceState::Empty, resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(StubLoaderTest, LoadDefaultDoesNothing)&#10;{&#10;    // StubLoader should not crash or throw when load_default is called&#10;    EXPECT_NO_THROW(stub_loader.load_default(resource));&#10;&#10;    // Resource state should remain unchanged&#10;    EXPECT_EQ(ResourceState::Empty, resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(StubLoaderTest, WorksWithDifferentResourceTypes)&#10;{&#10;    // Test with regular Resource&#10;    EXPECT_NO_THROW(stub_loader.load_default(resource));&#10;&#10;    // Test with Texture resource&#10;    EXPECT_NO_THROW(stub_loader.load_default(texture_resource));&#10;&#10;    Buffer data1 = Buffer::copy(&quot;data1&quot;, 5);&#10;    Buffer data2 = Buffer::copy(&quot;data2&quot;, 5);&#10;&#10;    EXPECT_NO_THROW(stub_loader.load(std::move(data1), resource));&#10;    EXPECT_NO_THROW(stub_loader.load(std::move(data2), texture_resource));&#10;}&#10;&#10;TEST_F(StubLoaderTest, WorksThroughBaseClass)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;StubLoader&gt;();&#10;&#10;    EXPECT_NO_THROW(loader-&gt;load_default(resource));&#10;&#10;    Buffer data = Buffer::copy(&quot;base class test&quot;, 15);&#10;    EXPECT_NO_THROW(loader-&gt;load(std::move(data), resource));&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;&#10;#include &quot;portal/engine/resources/loader/loader.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/core/buffer.h&quot;&#10;&#10;using namespace portal::resources;&#10;using namespace portal;&#10;&#10;// Mock implementation for testing the abstract interface&#10;class MockResourceLoader : public ResourceLoader&#10;{&#10;public:&#10;    MOCK_METHOD(void, load, (Buffer&amp;&amp; data, std::shared_ptr&lt;Resource&gt; resource), (override));&#10;    MOCK_METHOD(void, load_default, (std::shared_ptr&lt;Resource&gt; resource), (const, override));&#10;};&#10;&#10;class ResourceLoaderTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        resource = std::make_shared&lt;Resource&gt;(STRING_ID(&quot;test_resource&quot;));&#10;        test_data = Buffer::copy(&quot;test data&quot;, 9);&#10;    }&#10;&#10;    MockResourceLoader mock_loader;&#10;    std::shared_ptr&lt;Resource&gt; resource;&#10;    Buffer test_data;&#10;};&#10;&#10;TEST_F(ResourceLoaderTest, CanInstantiateMock)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;MockResourceLoader&gt;();&#10;    ASSERT_NE(nullptr, loader);&#10;}&#10;&#10;TEST_F(ResourceLoaderTest, CanCallLoad)&#10;{&#10;    EXPECT_CALL(mock_loader, load(::testing::_, resource))&#10;        .Times(1);&#10;&#10;    mock_loader.load(std::move(test_data), resource);&#10;}&#10;&#10;TEST_F(ResourceLoaderTest, CanCallLoadDefault)&#10;{&#10;    EXPECT_CALL(mock_loader, load_default(resource))&#10;        .Times(1);&#10;&#10;    mock_loader.load_default(resource);&#10;}&#10;&#10;TEST_F(ResourceLoaderTest, PolymorphicBehavior)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;MockResourceLoader&gt;();&#10;    auto* mock_ptr = dynamic_cast&lt;MockResourceLoader*&gt;(loader.get());&#10;&#10;    EXPECT_CALL(*mock_ptr, load(::testing::_, resource))&#10;        .Times(1);&#10;&#10;    Buffer data = Buffer::copy(&quot;polymorphic test&quot;, 16);&#10;    loader-&gt;load(std::move(data), resource);&#10;}&#10;&#10;// Test that the destructor is virtual (this should compile without issues)&#10;TEST_F(ResourceLoaderTest, VirtualDestructor)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;MockResourceLoader&gt;();&#10;    // If destructor wasn't virtual, this would be undefined behavior&#10;    loader.reset(); // Explicit destruction through base pointer&#10;    SUCCEED(); // If we get here, virtual destructor works correctly&#10;}&#10;&#10;// Tests for StubLoader&#10;class StubLoaderTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        resource = std::make_shared&lt;Resource&gt;(STRING_ID(&quot;test_resource&quot;));&#10;        texture_resource = std::make_shared&lt;Texture&gt;(STRING_ID(&quot;test_texture&quot;));&#10;        test_data = Buffer::copy(&quot;stub test data&quot;, 14);&#10;    }&#10;&#10;    StubLoader stub_loader;&#10;    std::shared_ptr&lt;Resource&gt; resource;&#10;    std::shared_ptr&lt;Texture&gt; texture_resource;&#10;    Buffer test_data;&#10;};&#10;&#10;TEST_F(StubLoaderTest, LoadDoesNothing)&#10;{&#10;    // StubLoader should not crash or throw when load is called&#10;    EXPECT_NO_THROW(stub_loader.load(std::move(test_data), resource));&#10;&#10;    // Resource state should remain unchanged&#10;    EXPECT_EQ(ResourceState::Empty, resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(StubLoaderTest, LoadDefaultDoesNothing)&#10;{&#10;    // StubLoader should not crash or throw when load_default is called&#10;    EXPECT_NO_THROW(stub_loader.load_default(resource));&#10;&#10;    // Resource state should remain unchanged&#10;    EXPECT_EQ(ResourceState::Empty, resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(StubLoaderTest, WorksWithDifferentResourceTypes)&#10;{&#10;    // Test with regular Resource&#10;    EXPECT_NO_THROW(stub_loader.load_default(resource));&#10;&#10;    // Test with Texture resource&#10;    EXPECT_NO_THROW(stub_loader.load_default(texture_resource));&#10;&#10;    Buffer data1 = Buffer::copy(&quot;data1&quot;, 5);&#10;    Buffer data2 = Buffer::copy(&quot;data2&quot;, 5);&#10;&#10;    EXPECT_NO_THROW(stub_loader.load(std::move(data1), resource));&#10;    EXPECT_NO_THROW(stub_loader.load(std::move(data2), texture_resource));&#10;}&#10;&#10;TEST_F(StubLoaderTest, WorksThroughBaseClass)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;StubLoader&gt;();&#10;&#10;    EXPECT_NO_THROW(loader-&gt;load_default(resource));&#10;&#10;    Buffer data = Buffer::copy(&quot;base class test&quot;, 15);&#10;    EXPECT_NO_THROW(loader-&gt;load(std::move(data), resource));&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/tests/resources/loader/texture_loader_tests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/tests/resources/loader/texture_loader_tests.cpp" />
              <option name="originalContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;#include &lt;array&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;portal/engine/resources/loader/image_loader.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/core/buffer.h&quot;&#10;#include &quot;portal/engine/resources/gpu_context.h&quot;&#10;#include &quot;portal/engine/renderer/allocated_image.h&quot;&#10;&#10;using namespace portal::resources;&#10;using namespace portal;&#10;&#10;static vk::raii::Device g_device = nullptr;&#10;static vk::raii::CommandBuffer g_command_buffer = nullptr;&#10;static vk::raii::Queue g_queue = nullptr;&#10;&#10;// Mock GpuContext for testing&#10;class MockGpuContext : public GpuContext&#10;{&#10;public:&#10;    // Create mock constructor that calls the real constructor with mock objects&#10;    MockGpuContext() : GpuContext(g_device, g_command_buffer,g_queue) {}&#10;&#10;    MOCK_METHOD(vulkan::AllocatedImage, create_image, (void* data, vulkan::ImageBuilder image_builder), (const, override));&#10;};&#10;&#10;class TextureLoaderTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;testing::StrictMock&lt;MockGpuContext&gt;&gt;();&#10;&#10;        // Set up default expectations for create_image using ByMove since AllocatedImage is move-only&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;&#10;        texture_resource = Ref&lt;Texture&gt;::create(STRING_ID(&quot;test_texture&quot;));&#10;        regular_resource = Ref&lt;Resource&gt;::create(STRING_ID(&quot;test_resource&quot;));&#10;&#10;        // Create a simple test PNG-like data (not a real PNG, just some bytes)&#10;        create_test_image_data();&#10;    }&#10;&#10;    void create_test_image_data()&#10;    {&#10;        // Create fake image data that could represent a simple image&#10;        // For testing purposes, we don't need real PNG data since we're mocking stbi&#10;        std::vector&lt;uint8_t&gt; fake_png_data = {&#10;            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature&#10;            0x00, 0x00, 0x00, 0x10, // Some fake data&#10;            0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00  // More fake data&#10;        };&#10;        test_image_data = Buffer::copy(fake_png_data.data(), fake_png_data.size());&#10;    }&#10;&#10;    std::shared_ptr&lt;testing::StrictMock&lt;MockGpuContext&gt;&gt; mock_gpu_context;&#10;    Ref&lt;Texture&gt; texture_resource;&#10;    Ref&lt;Resource&gt; regular_resource;&#10;    Buffer test_image_data;&#10;};&#10;&#10;TEST_F(TextureLoaderTest, ConstructorInitializesCorrectly)&#10;{&#10;    EXPECT_NO_THROW(ImageLoader loader(mock_gpu_context));&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadWithNonTextureResourceFails)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Loading a non-Texture resource should handle the error gracefully&#10;    Buffer data = Buffer::copy(&quot;not image data&quot;, 14);&#10;    EXPECT_NO_THROW(loader.load(std::move(data), regular_resource));&#10;&#10;    // Resource should remain in Empty state since load failed&#10;    EXPECT_EQ(ResourceState::Empty, regular_resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadDefaultWithNonTextureResourceFails)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Loading default for non-Texture resource should handle error gracefully&#10;    EXPECT_NO_THROW(loader.load_default(regular_resource));&#10;&#10;    // Resource should remain in Empty state since load failed&#10;    EXPECT_EQ(ResourceState::Empty, regular_resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadDefaultWithTextureResource)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Mock the create_image call that will be made during default texture creation&#10;    EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;        .Times(testing::AtLeast(1))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    EXPECT_NO_THROW(loader.load_default(texture_resource));&#10;&#10;    // Resource should be in Invalid state for default texture&#10;    EXPECT_EQ(ResourceState::Invalid, texture_resource-&gt;get_state());&#10;}&#10;&#10;// Test with invalid image data&#10;TEST_F(TextureLoaderTest, LoadWithInvalidImageData)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    Buffer invalid_data = Buffer::copy(&quot;not an image&quot;, 12);&#10;&#10;    // Should handle invalid image data gracefully&#10;    EXPECT_NO_THROW(loader.load(std::move(invalid_data), texture_resource));&#10;&#10;    // Resource should remain in Empty state since image loading failed&#10;    EXPECT_EQ(ResourceState::Empty, texture_resource-&gt;get_state());&#10;}&#10;&#10;// Test with empty data&#10;TEST_F(TextureLoaderTest, LoadWithEmptyData)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    Buffer empty_data;&#10;&#10;    EXPECT_NO_THROW(loader.load(std::move(empty_data), texture_resource));&#10;&#10;    // Resource should remain in Empty state&#10;    EXPECT_EQ(ResourceState::Empty, texture_resource-&gt;get_state());&#10;}&#10;&#10;// Test that multiple texture resources can be handled&#10;TEST_F(TextureLoaderTest, HandlesMultipleTextures)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    auto texture1 = Ref&lt;Texture&gt;::create(STRING_ID(&quot;texture1&quot;));&#10;    auto texture2 = Ref&lt;Texture&gt;::create(STRING_ID(&quot;texture2&quot;));&#10;&#10;    // Mock calls for default texture creation&#10;    EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;        .Times(testing::AtLeast(2))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    EXPECT_NO_THROW(loader.load_default(texture1));&#10;    EXPECT_NO_THROW(loader.load_default(texture2));&#10;&#10;    EXPECT_EQ(ResourceState::Invalid, texture1-&gt;get_state());&#10;    EXPECT_EQ(ResourceState::Invalid, texture2-&gt;get_state());&#10;}&#10;&#10;// Test polymorphic behavior through base class&#10;TEST_F(TextureLoaderTest, WorksThroughBaseClass)&#10;{&#10;    std::unique_ptr&lt;ResourceLoader&gt; loader = std::make_unique&lt;ImageLoader&gt;(mock_gpu_context);&#10;&#10;    // Mock the create_image call&#10;    EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;        .Times(testing::AtLeast(1))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    EXPECT_NO_THROW(loader-&gt;load_default(texture_resource));&#10;}&#10;&#10;// Test edge cases&#10;class TextureLoaderEdgeCaseTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;&#10;        // Set up default expectations for create_image&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;    }&#10;&#10;    std::shared_ptr&lt;MockGpuContext&gt; mock_gpu_context;&#10;};&#10;&#10;TEST_F(TextureLoaderEdgeCaseTest, ConstructorWithNullGpuContext)&#10;{&#10;    std::shared_ptr&lt;GpuContext&gt; null_context = nullptr;&#10;&#10;    // Constructor should handle null context gracefully or throw appropriately&#10;    // The actual behavior depends on the implementation&#10;    EXPECT_NO_THROW(ImageLoader loader(null_context));&#10;}&#10;&#10;TEST_F(TextureLoaderEdgeCaseTest, MultipleLoadCallsOnSameResource)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    auto texture = Ref&lt;Texture&gt;::create(STRING_ID(&quot;multi_load_texture&quot;));&#10;&#10;    // Mock multiple create_image calls&#10;    EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;        .Times(testing::AtLeast(2))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    // Multiple load_default calls should be handled safely&#10;    EXPECT_NO_THROW(loader.load_default(texture));&#10;    EXPECT_NO_THROW(loader.load_default(texture));&#10;}&#10;&#10;// Performance/stress test&#10;TEST_F(TextureLoaderEdgeCaseTest, HandlesLargeNumberOfResources)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Mock many create_image calls&#10;    EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;        .Times(testing::AtLeast(100))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    std::vector&lt;Ref&lt;Texture&gt;&gt; textures;&#10;    for (int i = 0; i &lt; 100; ++i)&#10;    {&#10;        // Use INVALID_STRING_ID for testing purposes since STRING_ID requires compile-time strings&#10;        auto texture = Ref&lt;Texture&gt;::create(INVALID_STRING_ID);&#10;        textures.push_back(texture);&#10;        EXPECT_NO_THROW(loader.load_default(texture));&#10;    }&#10;&#10;    // Verify all textures are in Invalid state (default texture state)&#10;    for (const auto&amp; texture : textures)&#10;    {&#10;        EXPECT_EQ(ResourceState::Invalid, texture-&gt;get_state());&#10;    }&#10;}&#10;&#10;// Test actual image loading with valid data&#10;TEST_F(TextureLoaderTest, LoadValidImageData)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Mock successful image creation&#10;    EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;        .Times(1)&#10;        .WillOnce(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;        }));&#10;&#10;    // Note: This test might fail in practice because stbi_load_from_memory&#10;    // will fail with our fake PNG data, but the test structure is correct&#10;    Buffer fake_image_data = Buffer::copy(test_image_data.data, test_image_data.size);&#10;    EXPECT_NO_THROW(loader.load(std::move(fake_image_data), texture_resource));&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;#include &lt;array&gt;&#10;#include &lt;memory&gt;&#10;&#10;#include &quot;portal/engine/resources/loader/image_loader.h&quot;&#10;#include &quot;portal/engine/resources/source/resource_source.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/core/buffer.h&quot;&#10;#include &quot;portal/engine/resources/gpu_context.h&quot;&#10;#include &quot;portal/engine/renderer/allocated_image.h&quot;&#10;&#10;using namespace portal::resources;&#10;using namespace portal;&#10;&#10;static vk::raii::Device g_device = nullptr;&#10;static vk::raii::CommandBuffer g_command_buffer = nullptr;&#10;static vk::raii::Queue g_queue = nullptr;&#10;&#10;// Mock GpuContext for testing&#10;class MockGpuContext : public GpuContext&#10;{&#10;public:&#10;    // Create mock constructor that calls the real constructor with mock objects&#10;    MockGpuContext() : GpuContext(g_device, g_command_buffer, g_queue) {}&#10;&#10;    MOCK_METHOD(vulkan::AllocatedImage, create_image, (void* data, vulkan::ImageBuilder image_builder), (const, override));&#10;};&#10;&#10;// Mock ResourceSource for testing&#10;class MockResourceSource : public ResourceSource&#10;{&#10;public:&#10;    MOCK_METHOD(SourceMetadata, get_meta, (), (const, override));&#10;    MOCK_METHOD(Buffer, load, (), (override));&#10;};&#10;&#10;class TextureLoaderTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;testing::StrictMock&lt;MockGpuContext&gt;&gt;();&#10;        mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;&#10;        // Set up default expectations for create_image using ByMove since AllocatedImage is move-only&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;&#10;        texture_resource = Ref&lt;Texture&gt;::create(STRING_ID(&quot;test_texture&quot;));&#10;        regular_resource = Ref&lt;Resource&gt;::create(STRING_ID(&quot;test_resource&quot;));&#10;&#10;        // Create a simple test PNG-like data (not a real PNG, just some bytes)&#10;        create_test_image_data();&#10;    }&#10;&#10;    void create_test_image_data()&#10;    {&#10;        // Create fake image data that could represent a simple image&#10;        // For testing purposes, we don't need real PNG data since we're mocking stbi&#10;        std::vector&lt;uint8_t&gt; fake_png_data = {&#10;            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature&#10;            0x00, 0x00, 0x00, 0x10, // Some fake data&#10;            0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00  // More fake data&#10;        };&#10;        test_image_data = Buffer::copy(fake_png_data.data(), fake_png_data.size());&#10;    }&#10;&#10;    std::shared_ptr&lt;testing::StrictMock&lt;MockGpuContext&gt;&gt; mock_gpu_context;&#10;    std::shared_ptr&lt;MockResourceSource&gt; mock_source;&#10;    Ref&lt;Texture&gt; texture_resource;&#10;    Ref&lt;Resource&gt; regular_resource;&#10;    Buffer test_image_data;&#10;};&#10;&#10;TEST_F(TextureLoaderTest, ConstructorInitializesCorrectly)&#10;{&#10;    EXPECT_NO_THROW(ImageLoader loader(mock_gpu_context));&#10;}&#10;&#10;TEST_F(TextureLoaderTest, InitializesWithSource)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;test_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;&#10;    EXPECT_NO_THROW(loader.init(mock_source));&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadWithNonTextureResourceFails)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    // Initialize with mock source&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;test_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    loader.init(mock_source);&#10;&#10;    // Loading a non-Texture resource should return false&#10;    bool result = loader.load(regular_resource);&#10;    EXPECT_FALSE(result);&#10;&#10;    // Resource should remain in Empty state since load failed&#10;    EXPECT_EQ(ResourceState::Empty, regular_resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadDefaultWithNonTextureResourceFails)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Loading default for non-Texture resource should handle error gracefully&#10;    EXPECT_NO_THROW(loader.load_default(regular_resource));&#10;&#10;    // Resource should remain in Empty state since load failed&#10;    EXPECT_EQ(ResourceState::Empty, regular_resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadDefaultWithTextureResource)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;&#10;    // Load default should work without initialization&#10;    EXPECT_NO_THROW(loader.load_default(texture_resource));&#10;&#10;    // Resource should be in Invalid state (default texture loaded)&#10;    EXPECT_EQ(ResourceState::Invalid, texture_resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadWithValidTextureData)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    // Set up mock source expectations&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;test_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    EXPECT_CALL(*mock_source, load())&#10;        .WillOnce(testing::Return(std::move(test_image_data)));&#10;&#10;    loader.init(mock_source);&#10;&#10;    // Note: This test may fail because stbi_load_from_memory will fail with fake PNG data&#10;    // In a real scenario, you'd need valid image data or mock stbi functions&#10;    bool result = loader.load(texture_resource);&#10;    &#10;    // The result depends on whether stbi can decode our fake data&#10;    // For this test, we expect it to fail gracefully&#10;    EXPECT_FALSE(result);&#10;}&#10;&#10;TEST_F(TextureLoaderTest, GetSignatureReturnsEmptyVector)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    auto signatures = loader.get_signature();&#10;    EXPECT_TRUE(signatures.empty());&#10;}&#10;&#10;TEST_F(TextureLoaderTest, LoadWithEmptyBuffer)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    // Set up mock source to return empty buffer&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;test_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    EXPECT_CALL(*mock_source, load())&#10;        .WillOnce(testing::Return(Buffer{})); // Empty buffer&#10;&#10;    loader.init(mock_source);&#10;&#10;    bool result = loader.load(texture_resource);&#10;    EXPECT_FALSE(result); // Should fail with empty buffer&#10;}&#10;&#10;TEST_F(TextureLoaderTest, MultipleInitCallsWork)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    auto second_source = std::make_shared&lt;MockResourceSource&gt;();&#10;    &#10;    // First init&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;first_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    loader.init(mock_source);&#10;&#10;    // Second init should replace the first&#10;    EXPECT_CALL(*second_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;second_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    EXPECT_NO_THROW(loader.init(second_source));&#10;}&#10;&#10;// Integration-style test&#10;TEST_F(TextureLoaderTest, CompleteLoadingWorkflow)&#10;{&#10;    ImageLoader loader(mock_gpu_context);&#10;    &#10;    // 1. Initialize with source&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillOnce(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;workflow_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    loader.init(mock_source);&#10;&#10;    // 2. Load default first&#10;    loader.load_default(texture_resource);&#10;    EXPECT_EQ(ResourceState::Invalid, texture_resource-&gt;get_state());&#10;&#10;    // 3. Attempt to load actual data (will fail with fake data)&#10;    EXPECT_CALL(*mock_source, load())&#10;        .WillOnce(testing::Return(std::move(test_image_data)));&#10;    &#10;    bool result = loader.load(texture_resource);&#10;    EXPECT_FALSE(result); // Expected to fail with fake PNG data&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/tests/resources/registry/resource_registry_tests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/tests/resources/registry/resource_registry_tests.cpp" />
              <option name="originalContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;chrono&gt;&#10;&#10;#include &quot;portal/engine/resources/resource_registry.h&quot;&#10;#include &quot;portal/engine/resources/database/resource_database.h&quot;&#10;#include &quot;portal/engine/resources/source/resource_source.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/resources/gpu_context.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/core/buffer.h&quot;&#10;#include &quot;portal/engine/renderer/allocated_image.h&quot;&#10;&#10;using namespace portal;&#10;using namespace portal::resources;&#10;using namespace std::chrono_literals;&#10;&#10;// Mock classes for dependencies&#10;class MockResourceDatabase : public ResourceDatabase&#10;{&#10;public:&#10;    MOCK_METHOD(std::shared_ptr&lt;ResourceSource&gt;, get_source, (StringId id), (const, override));&#10;};&#10;&#10;class MockResourceSource : public ResourceSource&#10;{&#10;public:&#10;    MOCK_METHOD(SourceMetadata, get_meta, (), (const, override));&#10;    MOCK_METHOD(Buffer, load, (), (override));&#10;};&#10;&#10;class MockGpuContext : public GpuContext&#10;{&#10;public:&#10;    MockGpuContext() : GpuContext(&#10;        *reinterpret_cast&lt;vk::raii::Device*&gt;(&amp;mock_device),&#10;        *reinterpret_cast&lt;vk::raii::CommandBuffer*&gt;(&amp;mock_command_buffer),&#10;        *reinterpret_cast&lt;vk::raii::Queue*&gt;(&amp;mock_queue)&#10;    ) {}&#10;&#10;    MOCK_METHOD(vulkan::AllocatedImage, create_image, (void* data, vulkan::ImageBuilder image_builder), (const, override));&#10;&#10;private:&#10;    int mock_device{};&#10;    int mock_command_buffer{};&#10;    int mock_queue{};&#10;};&#10;&#10;class ResourceRegistryTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;        mock_database = std::make_shared&lt;MockResourceDatabase&gt;();&#10;&#10;        // Set up default GPU context expectations&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;&#10;        registry.initialize(mock_gpu_context, mock_database);&#10;&#10;        test_texture_id = STRING_ID(&quot;test_texture&quot;);&#10;        test_resource_id = STRING_ID(&quot;test_resource&quot;);&#10;    }&#10;&#10;    void TearDown() override&#10;    {&#10;        registry.shutdown();&#10;    }&#10;&#10;    // Helper method to create a mock source that returns valid data&#10;    static std::shared_ptr&lt;MockResourceSource&gt; create_mock_source_with_data(const std::string&amp; data)&#10;    {&#10;        auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;        EXPECT_CALL(*mock_source, get_meta())&#10;            .WillRepeatedly(testing::Return(SourceMetadata{&#10;                STRING_ID(&quot;test_source&quot;),&#10;                ResourceType::Texture,&#10;                SourceFormat::Image&#10;            }));&#10;        EXPECT_CALL(*mock_source, load())&#10;            .WillOnce(testing::Return(Buffer::copy(data.c_str(), data.size())));&#10;        return mock_source;&#10;    }&#10;&#10;    // Helper method to create a mock source that returns empty data&#10;    static std::shared_ptr&lt;MockResourceSource&gt; create_mock_source_empty()&#10;    {&#10;        auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;        EXPECT_CALL(*mock_source, get_meta())&#10;            .WillRepeatedly(testing::Return(SourceMetadata{&#10;                INVALID_STRING_ID,&#10;                ResourceType::Unknown,&#10;                SourceFormat::Unknown&#10;            }));&#10;        EXPECT_CALL(*mock_source, load())&#10;            .WillOnce(testing::Return(Buffer{})); // Empty buffer&#10;        return mock_source;&#10;    }&#10;&#10;    ResourceRegistry registry;&#10;    std::shared_ptr&lt;MockGpuContext&gt; mock_gpu_context;&#10;    std::shared_ptr&lt;MockResourceDatabase&gt; mock_database;&#10;    StringId test_texture_id{INVALID_STRING_ID};&#10;    StringId test_resource_id{INVALID_STRING_ID};&#10;};&#10;&#10;TEST_F(ResourceRegistryTest, InitializesCorrectly)&#10;{&#10;    ResourceRegistry new_registry;&#10;    auto new_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;    auto new_database = std::make_shared&lt;MockResourceDatabase&gt;();&#10;&#10;    // Set up GPU context expectations&#10;    EXPECT_CALL(*new_gpu_context, create_image(testing::_, testing::_))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{};&#10;        }));&#10;&#10;    EXPECT_NO_THROW(new_registry.initialize(new_gpu_context, new_database));&#10;    EXPECT_NO_THROW(new_registry.shutdown());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, GetCreatesNewResource)&#10;{&#10;    // Mock database to return a source with data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    // Get a texture resource&#10;    auto texture = registry.get&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;    EXPECT_EQ(test_texture_id, texture-&gt;id);&#10;&#10;    // Resource should initially be in Invalid state (default texture loaded)&#10;    EXPECT_EQ(ResourceState::Invalid, texture-&gt;get_state());&#10;&#10;    // Give some time for background loading&#10;    std::this_thread::sleep_for(100ms);&#10;&#10;    // After background loading, it should be loaded&#10;    // Note: This might be flaky in practice due to threading&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, GetReturnsSameResourceForSameId)&#10;{&#10;    // Mock database to return a source&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto texture1 = registry.get&lt;Texture&gt;(test_texture_id);&#10;    auto texture2 = registry.get&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture1.get());&#10;    ASSERT_NE(nullptr, texture2.get());&#10;    EXPECT_EQ(texture1.get(), texture2.get()); // Should be the same instance&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, GetWithResourceTypeWorks)&#10;{&#10;    // Mock database to return a source&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto resource = registry.get(test_texture_id, ResourceType::Texture);&#10;&#10;    ASSERT_NE(nullptr, resource.get());&#10;    EXPECT_EQ(test_texture_id, resource-&gt;id);&#10;&#10;    // Should be able to cast to Texture&#10;    auto texture = resource.as&lt;Texture&gt;();&#10;    EXPECT_NE(nullptr, texture.get());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, ImmediateLoadLoadsResourceSynchronously)&#10;{&#10;    // Mock database to return a source with data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto texture = registry.immediate_load&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;    EXPECT_EQ(test_texture_id, texture-&gt;id);&#10;&#10;    // Resource should be loaded immediately (not just Invalid state)&#10;    EXPECT_EQ(ResourceState::Loaded, texture-&gt;get_state());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, ImmediateLoadWithResourceTypeWorks)&#10;{&#10;    // Mock database to return a source with data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto resource = registry.immediate_load(test_texture_id, ResourceType::Texture);&#10;&#10;    ASSERT_NE(nullptr, resource.get());&#10;    EXPECT_EQ(test_texture_id, resource-&gt;id);&#10;    EXPECT_EQ(ResourceState::Loaded, resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, UnloadHandlesValidResource)&#10;{&#10;    // Mock database to return a source&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    // First get the resource to create it&#10;    auto texture = registry.get&lt;Texture&gt;(test_texture_id);&#10;    ASSERT_NE(nullptr, texture.get());&#10;&#10;    // Then unload it&#10;    EXPECT_NO_THROW(registry.unload(test_texture_id));&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, UnloadHandlesInvalidResource)&#10;{&#10;    StringId non_existent_id = STRING_ID(&quot;non_existent&quot;);&#10;&#10;    // Should not crash when unloading non-existent resource&#10;    EXPECT_NO_THROW(registry.unload(non_existent_id));&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, HandlesResourceWithMissingData)&#10;{&#10;    // Mock database to return a source that provides no data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_empty()));&#10;&#10;    auto texture = registry.immediate_load&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;&#10;    // Resource should be marked as missing since source returned empty data&#10;    EXPECT_EQ(ResourceState::Missing, texture-&gt;get_state());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, HandlesMultipleResourceTypes)&#10;{&#10;    StringId mesh_id = STRING_ID(&quot;test_mesh&quot;);&#10;&#10;    // Mock database calls for different resource types&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    EXPECT_CALL(*mock_database, get_source(mesh_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;mesh data&quot;)));&#10;&#10;    auto texture = registry.get&lt;Texture&gt;(test_texture_id);&#10;    auto mesh = registry.get(mesh_id, ResourceType::Mesh);&#10;    std::this_thread::sleep_for(10ms); // Allow time for background loading&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;    ASSERT_NE(nullptr, mesh.get());&#10;    EXPECT_NE(texture.get(), mesh.get()); // Should be different instances&#10;}&#10;&#10;// Note: Since increment_ref and decrement_ref are private, we can only test&#10;// the public interface. The reference counting is tested indirectly through&#10;// the ResourceRegistry tests which use these methods internally.&#10;&#10;// Integration tests&#10;class ResourceRegistryIntegrationTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;        mock_database = std::make_shared&lt;MockResourceDatabase&gt;();&#10;&#10;        // Set up default GPU context expectations&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{};&#10;            }));&#10;&#10;        registry.initialize(mock_gpu_context, mock_database);&#10;    }&#10;&#10;    void TearDown() override&#10;    {&#10;        registry.shutdown();&#10;    }&#10;&#10;    ResourceRegistry registry;&#10;    std::shared_ptr&lt;MockGpuContext&gt; mock_gpu_context;&#10;    std::shared_ptr&lt;MockResourceDatabase&gt; mock_database;&#10;};&#10;&#10;TEST_F(ResourceRegistryIntegrationTest, LoadAndUnloadCycle)&#10;{&#10;    StringId texture_id = STRING_ID(&quot;cycle_texture&quot;);&#10;&#10;    // Create a mock source with expectations&#10;    auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillRepeatedly(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;test_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    EXPECT_CALL(*mock_source, load())&#10;        .WillOnce(testing::Return(Buffer::copy(&quot;texture&quot;, 7)));&#10;&#10;    // Mock database to return the source&#10;    EXPECT_CALL(*mock_database, get_source(texture_id))&#10;        .WillOnce(testing::Return(mock_source));&#10;&#10;    // Load the resource&#10;    auto texture = registry.immediate_load&lt;Texture&gt;(texture_id);&#10;    ASSERT_NE(nullptr, texture.get());&#10;    EXPECT_EQ(ResourceState::Loaded, texture-&gt;get_state());&#10;&#10;    // Unload the resource&#10;    EXPECT_NO_THROW(registry.unload(texture_id));&#10;}&#10;&#10;TEST_F(ResourceRegistryIntegrationTest, MultipleResourcesSimultaneousAccess)&#10;{&#10;    const int num_resources = 5;&#10;    std::vector&lt;StringId&gt; resource_ids;&#10;&#10;    // Use predefined StringIds to avoid runtime string generation&#10;    resource_ids.push_back(STRING_ID(&quot;resource_0&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_1&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_2&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_3&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_4&quot;));&#10;&#10;    // Set up mock expectations for each resource&#10;    for (int i = 0; i &lt; num_resources; ++i)&#10;    {&#10;        auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;        EXPECT_CALL(*mock_source, get_meta())&#10;            .WillRepeatedly(testing::Return(SourceMetadata{&#10;                STRING_ID(&quot;test_source&quot;),&#10;                ResourceType::Texture,&#10;                SourceFormat::Image&#10;            }));&#10;        EXPECT_CALL(*mock_source, load())&#10;            .WillOnce(testing::Return(Buffer::copy(&quot;data&quot;, 4)));&#10;&#10;        EXPECT_CALL(*mock_database, get_source(resource_ids[i]))&#10;            .WillOnce(testing::Return(mock_source));&#10;    }&#10;&#10;    std::vector&lt;std::thread&gt; threads;&#10;    std::vector&lt;Ref&lt;Texture&gt;&gt; textures(num_resources);&#10;&#10;    // Create threads that simultaneously access different resources&#10;    for (int i = 0; i &lt; num_resources; ++i)&#10;    {&#10;        threads.emplace_back([&amp;, i]() {&#10;            textures[i] = registry.get&lt;Texture&gt;(resource_ids[i]);&#10;        });&#10;    }&#10;&#10;    // Wait for all threads to complete&#10;    for (auto&amp; thread : threads)&#10;    {&#10;        thread.join();&#10;    }&#10;&#10;    std::this_thread::sleep_for(100ms); // Allow time for background loading&#10;&#10;    // Verify all resources were loaded&#10;    for (int i = 0; i &lt; num_resources; ++i)&#10;    {&#10;        ASSERT_NE(nullptr, textures[i].get());&#10;        EXPECT_EQ(resource_ids[i], textures[i]-&gt;id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Copyright  2025 Jonatan Nevo.&#10;// Distributed under the MIT license (see LICENSE file).&#10;//&#10;&#10;#include &lt;gtest/gtest.h&gt;&#10;#include &lt;gmock/gmock.h&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;chrono&gt;&#10;&#10;#include &quot;portal/engine/resources/resource_registry.h&quot;&#10;#include &quot;portal/engine/resources/database/resource_database.h&quot;&#10;#include &quot;portal/engine/resources/source/resource_source.h&quot;&#10;#include &quot;portal/engine/resources/resources/resource.h&quot;&#10;#include &quot;portal/engine/resources/gpu_context.h&quot;&#10;#include &quot;portal/engine/strings/string_id.h&quot;&#10;#include &quot;portal/core/buffer.h&quot;&#10;#include &quot;portal/engine/renderer/allocated_image.h&quot;&#10;&#10;using namespace portal;&#10;using namespace portal::resources;&#10;using namespace std::chrono_literals;&#10;&#10;// Mock classes for dependencies&#10;class MockResourceDatabase : public ResourceDatabase&#10;{&#10;public:&#10;    MOCK_METHOD(std::shared_ptr&lt;ResourceSource&gt;, get_source, (StringId id), (const, override));&#10;};&#10;&#10;class MockResourceSource : public ResourceSource&#10;{&#10;public:&#10;    MOCK_METHOD(SourceMetadata, get_meta, (), (const, override));&#10;    MOCK_METHOD(Buffer, load, (), (override));&#10;};&#10;&#10;class MockGpuContext : public GpuContext&#10;{&#10;public:&#10;    MockGpuContext() : GpuContext(&#10;        *reinterpret_cast&lt;vk::raii::Device*&gt;(&amp;mock_device),&#10;        *reinterpret_cast&lt;vk::raii::CommandBuffer*&gt;(&amp;mock_command_buffer),&#10;        *reinterpret_cast&lt;vk::raii::Queue*&gt;(&amp;mock_queue)&#10;    ) {}&#10;&#10;    MOCK_METHOD(vulkan::AllocatedImage, create_image, (void* data, vulkan::ImageBuilder image_builder), (const, override));&#10;&#10;private:&#10;    int mock_device{};&#10;    int mock_command_buffer{};&#10;    int mock_queue{};&#10;};&#10;&#10;class ResourceRegistryTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;        mock_database = std::make_shared&lt;MockResourceDatabase&gt;();&#10;&#10;        // Set up default GPU context expectations&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{}; // Return by value, will be moved&#10;            }));&#10;&#10;        registry.initialize(mock_gpu_context, mock_database);&#10;&#10;        test_texture_id = STRING_ID(&quot;test_texture&quot;);&#10;        test_resource_id = STRING_ID(&quot;test_resource&quot;);&#10;    }&#10;&#10;    void TearDown() override&#10;    {&#10;        registry.shutdown();&#10;    }&#10;&#10;    // Helper method to create a mock source that returns valid data&#10;    static std::shared_ptr&lt;MockResourceSource&gt; create_mock_source_with_data(const std::string&amp; data)&#10;    {&#10;        auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;        EXPECT_CALL(*mock_source, get_meta())&#10;            .WillRepeatedly(testing::Return(SourceMetadata{&#10;                STRING_ID(&quot;test_source&quot;),&#10;                ResourceType::Texture,&#10;                SourceFormat::Image&#10;            }));&#10;        EXPECT_CALL(*mock_source, load())&#10;            .WillOnce(testing::Return(Buffer::copy(data.c_str(), data.size())));&#10;        return mock_source;&#10;    }&#10;&#10;    // Helper method to create a mock source that returns empty data&#10;    static std::shared_ptr&lt;MockResourceSource&gt; create_mock_source_empty()&#10;    {&#10;        auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;        EXPECT_CALL(*mock_source, get_meta())&#10;            .WillRepeatedly(testing::Return(SourceMetadata{&#10;                INVALID_STRING_ID,&#10;                ResourceType::Unknown,&#10;                SourceFormat::Unknown&#10;            }));&#10;        EXPECT_CALL(*mock_source, load())&#10;            .WillOnce(testing::Return(Buffer{})); // Empty buffer&#10;        return mock_source;&#10;    }&#10;&#10;    ResourceRegistry registry;&#10;    std::shared_ptr&lt;MockGpuContext&gt; mock_gpu_context;&#10;    std::shared_ptr&lt;MockResourceDatabase&gt; mock_database;&#10;    StringId test_texture_id{INVALID_STRING_ID};&#10;    StringId test_resource_id{INVALID_STRING_ID};&#10;};&#10;&#10;TEST_F(ResourceRegistryTest, InitializesCorrectly)&#10;{&#10;    ResourceRegistry new_registry;&#10;    auto new_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;    auto new_database = std::make_shared&lt;MockResourceDatabase&gt;();&#10;&#10;    // Set up GPU context expectations&#10;    EXPECT_CALL(*new_gpu_context, create_image(testing::_, testing::_))&#10;        .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;            return vulkan::AllocatedImage{};&#10;        }));&#10;&#10;    EXPECT_NO_THROW(new_registry.initialize(new_gpu_context, new_database));&#10;    EXPECT_NO_THROW(new_registry.shutdown());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, GetCreatesNewResource)&#10;{&#10;    // Mock database to return a source with data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    // Get a texture resource&#10;    auto texture = registry.get&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;    EXPECT_EQ(test_texture_id, texture-&gt;id);&#10;&#10;    // Resource should initially be in Invalid state (default texture loaded)&#10;    EXPECT_EQ(ResourceState::Invalid, texture-&gt;get_state());&#10;&#10;    // Give some time for background loading&#10;    std::this_thread::sleep_for(100ms);&#10;&#10;    // After background loading, it should be loaded&#10;    // Note: This might be flaky in practice due to threading&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, GetReturnsSameResourceForSameId)&#10;{&#10;    // Mock database to return a source&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto texture1 = registry.get&lt;Texture&gt;(test_texture_id);&#10;    auto texture2 = registry.get&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture1.get());&#10;    ASSERT_NE(nullptr, texture2.get());&#10;    EXPECT_EQ(texture1.get(), texture2.get()); // Should be the same instance&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, GetWithResourceTypeWorks)&#10;{&#10;    // Mock database to return a source&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto resource = registry.get(test_texture_id, ResourceType::Texture);&#10;&#10;    ASSERT_NE(nullptr, resource.get());&#10;    EXPECT_EQ(test_texture_id, resource-&gt;id);&#10;&#10;    // Should be able to cast to Texture&#10;    auto texture = resource.as&lt;Texture&gt;();&#10;    EXPECT_NE(nullptr, texture.get());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, ImmediateLoadLoadsResourceSynchronously)&#10;{&#10;    // Mock database to return a source with data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto texture = registry.immediate_load&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;    EXPECT_EQ(test_texture_id, texture-&gt;id);&#10;&#10;    // Resource should be loaded immediately (not just Invalid state)&#10;    EXPECT_EQ(ResourceState::Loaded, texture-&gt;get_state());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, ImmediateLoadWithResourceTypeWorks)&#10;{&#10;    // Mock database to return a source with data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    auto resource = registry.immediate_load(test_texture_id, ResourceType::Texture);&#10;&#10;    ASSERT_NE(nullptr, resource.get());&#10;    EXPECT_EQ(test_texture_id, resource-&gt;id);&#10;    EXPECT_EQ(ResourceState::Loaded, resource-&gt;get_state());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, UnloadHandlesValidResource)&#10;{&#10;    // Mock database to return a source&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    // First get the resource to create it&#10;    auto texture = registry.get&lt;Texture&gt;(test_texture_id);&#10;    ASSERT_NE(nullptr, texture.get());&#10;&#10;    // Then unload it&#10;    EXPECT_NO_THROW(registry.unload(test_texture_id));&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, UnloadHandlesInvalidResource)&#10;{&#10;    StringId non_existent_id = STRING_ID(&quot;non_existent&quot;);&#10;&#10;    // Should not crash when unloading non-existent resource&#10;    EXPECT_NO_THROW(registry.unload(non_existent_id));&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, HandlesResourceWithMissingData)&#10;{&#10;    // Mock database to return a source that provides no data&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_empty()));&#10;&#10;    auto texture = registry.immediate_load&lt;Texture&gt;(test_texture_id);&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;&#10;    // Resource should be marked as missing since source returned empty data&#10;    EXPECT_EQ(ResourceState::Missing, texture-&gt;get_state());&#10;}&#10;&#10;TEST_F(ResourceRegistryTest, HandlesMultipleResourceTypes)&#10;{&#10;    StringId mesh_id = STRING_ID(&quot;test_mesh&quot;);&#10;&#10;    // Mock database calls for different resource types&#10;    EXPECT_CALL(*mock_database, get_source(test_texture_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;texture data&quot;)));&#10;&#10;    EXPECT_CALL(*mock_database, get_source(mesh_id))&#10;        .WillOnce(testing::Return(create_mock_source_with_data(&quot;mesh data&quot;)));&#10;&#10;    auto texture = registry.get&lt;Texture&gt;(test_texture_id);&#10;    auto mesh = registry.get(mesh_id, ResourceType::Mesh);&#10;    std::this_thread::sleep_for(10ms); // Allow time for background loading&#10;&#10;    ASSERT_NE(nullptr, texture.get());&#10;    ASSERT_NE(nullptr, mesh.get());&#10;    EXPECT_NE(texture.get(), mesh.get()); // Should be different instances&#10;}&#10;&#10;// Note: Since increment_ref and decrement_ref are private, we can only test&#10;// the public interface. The reference counting is tested indirectly through&#10;// the ResourceRegistry tests which use these methods internally.&#10;&#10;// Integration tests&#10;class ResourceRegistryIntegrationTest : public ::testing::Test&#10;{&#10;protected:&#10;    void SetUp() override&#10;    {&#10;        mock_gpu_context = std::make_shared&lt;MockGpuContext&gt;();&#10;        mock_database = std::make_shared&lt;MockResourceDatabase&gt;();&#10;&#10;        // Set up default GPU context expectations&#10;        EXPECT_CALL(*mock_gpu_context, create_image(testing::_, testing::_))&#10;            .WillRepeatedly(testing::Invoke([](void*, const vulkan::ImageBuilder&amp;) {&#10;                return vulkan::AllocatedImage{};&#10;            }));&#10;&#10;        registry.initialize(mock_gpu_context, mock_database);&#10;    }&#10;&#10;    void TearDown() override&#10;    {&#10;        registry.shutdown();&#10;    }&#10;&#10;    ResourceRegistry registry;&#10;    std::shared_ptr&lt;MockGpuContext&gt; mock_gpu_context;&#10;    std::shared_ptr&lt;MockResourceDatabase&gt; mock_database;&#10;};&#10;&#10;TEST_F(ResourceRegistryIntegrationTest, LoadAndUnloadCycle)&#10;{&#10;    StringId texture_id = STRING_ID(&quot;cycle_texture&quot;);&#10;&#10;    // Create valid minimal PNG data (1x1 pixel transparent PNG)&#10;    // This is a real PNG file that stbi can decode&#10;    std::vector&lt;uint8_t&gt; valid_png_data = {&#10;        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature&#10;        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // IHDR chunk&#10;        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, // 1x1 dimensions&#10;        0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, // bit depth, color type, etc.&#10;        0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, // IDAT chunk start&#10;        0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00, // compressed data&#10;        0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00, // end of IDAT&#10;        0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, // IEND chunk&#10;        0x42, 0x60, 0x82&#10;    };&#10;&#10;    // Create a mock source with expectations&#10;    auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;    EXPECT_CALL(*mock_source, get_meta())&#10;        .WillRepeatedly(testing::Return(SourceMetadata{&#10;            STRING_ID(&quot;test_source&quot;),&#10;            ResourceType::Texture,&#10;            SourceFormat::Image&#10;        }));&#10;    EXPECT_CALL(*mock_source, load())&#10;        .WillOnce(testing::Return(Buffer::copy(valid_png_data.data(), valid_png_data.size())));&#10;&#10;    // Mock database to return the source&#10;    EXPECT_CALL(*mock_database, get_source(texture_id))&#10;        .WillOnce(testing::Return(mock_source));&#10;&#10;    // Load the resource&#10;    auto texture = registry.immediate_load&lt;Texture&gt;(texture_id);&#10;    ASSERT_NE(nullptr, texture.get());&#10;    EXPECT_EQ(ResourceState::Loaded, texture-&gt;get_state());&#10;&#10;    // Unload the resource&#10;    EXPECT_NO_THROW(registry.unload(texture_id));&#10;}&#10;&#10;TEST_F(ResourceRegistryIntegrationTest, MultipleResourcesSimultaneousAccess)&#10;{&#10;    const int num_resources = 5;&#10;    std::vector&lt;StringId&gt; resource_ids;&#10;&#10;    // Use predefined StringIds to avoid runtime string generation&#10;    resource_ids.push_back(STRING_ID(&quot;resource_0&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_1&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_2&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_3&quot;));&#10;    resource_ids.push_back(STRING_ID(&quot;resource_4&quot;));&#10;&#10;    // Set up mock expectations for each resource&#10;    for (int i = 0; i &lt; num_resources; ++i)&#10;    {&#10;        auto mock_source = std::make_shared&lt;MockResourceSource&gt;();&#10;        EXPECT_CALL(*mock_source, get_meta())&#10;            .WillRepeatedly(testing::Return(SourceMetadata{&#10;                STRING_ID(&quot;test_source&quot;),&#10;                ResourceType::Texture,&#10;                SourceFormat::Image&#10;            }));&#10;        EXPECT_CALL(*mock_source, load())&#10;            .WillOnce(testing::Return(Buffer::copy(&quot;data&quot;, 4)));&#10;&#10;        EXPECT_CALL(*mock_database, get_source(resource_ids[i]))&#10;            .WillOnce(testing::Return(mock_source));&#10;    }&#10;&#10;    std::vector&lt;std::thread&gt; threads;&#10;    std::vector&lt;Ref&lt;Texture&gt;&gt; textures(num_resources);&#10;&#10;    // Create threads that simultaneously access different resources&#10;    for (int i = 0; i &lt; num_resources; ++i)&#10;    {&#10;        threads.emplace_back([&amp;, i]() {&#10;            textures[i] = registry.get&lt;Texture&gt;(resource_ids[i]);&#10;        });&#10;    }&#10;&#10;    // Wait for all threads to complete&#10;    for (auto&amp; thread : threads)&#10;    {&#10;        thread.join();&#10;    }&#10;&#10;    std::this_thread::sleep_for(100ms); // Allow time for background loading&#10;&#10;    // Verify all resources were loaded&#10;    for (int i = 0; i &lt; num_resources; ++i)&#10;    {&#10;        ASSERT_NE(nullptr, textures[i].get());&#10;        EXPECT_EQ(resource_ids[i], textures[i]-&gt;id);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/tests/resources/source/file_source_tests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/tests/resources/source/file_source_tests.cpp" />
              <option name="originalContent" value="// //&#10;// // Copyright  2025 Jonatan Nevo.&#10;// // Distributed under the MIT license (see LICENSE file).&#10;// //&#10;//&#10;// #include &lt;gtest/gtest.h&gt;&#10;// #include &lt;gmock/gmock.h&gt;&#10;// #include &lt;filesystem&gt;&#10;// #include &lt;fstream&gt;&#10;//&#10;// #include &quot;portal/engine/resources/source/file_source.h&quot;&#10;// #include &quot;portal/engine/resources/resource_types.h&quot;&#10;// #include &quot;portal/core/buffer.h&quot;&#10;//&#10;// using namespace portal::resources;&#10;// using namespace portal;&#10;//&#10;// class FileSourceTest : public ::testing::Test&#10;// {&#10;// protected:&#10;//     void SetUp() override&#10;//     {&#10;//         // Create temporary test directory&#10;//         test_dir = std::filesystem::temp_directory_path() / &quot;portal_file_source_tests&quot;;&#10;//         std::filesystem::create_directories(test_dir);&#10;//&#10;//         // Create test files with different extensions&#10;//         create_test_file(&quot;test_texture.png&quot;, &quot;fake png data&quot;);&#10;//         create_test_file(&quot;test_mesh.obj&quot;, &quot;fake obj data&quot;);&#10;//         create_test_file(&quot;test_material.mtl&quot;, &quot;fake mtl data&quot;);&#10;//         create_test_file(&quot;test_shader.slang&quot;, &quot;fake slang data&quot;);&#10;//         create_test_file(&quot;test_composite.glb&quot;, &quot;fake glb data&quot;);&#10;//         create_test_file(&quot;test_unknown.xyz&quot;, &quot;unknown file type&quot;);&#10;//     }&#10;//&#10;//     void TearDown() override&#10;//     {&#10;//         // Clean up test files&#10;//         std::filesystem::remove_all(test_dir);&#10;//     }&#10;//&#10;//     void create_test_file(const std::string&amp; filename, const std::string&amp; content)&#10;//     {&#10;//         auto file_path = test_dir / filename;&#10;//         std::ofstream file(file_path);&#10;//         file &lt;&lt; content;&#10;//     }&#10;//&#10;//     std::filesystem::path test_dir;&#10;// };&#10;//&#10;// // Test resource type detection for various file extensions&#10;// TEST_F(FileSourceTest, DetectsTextureType)&#10;// {&#10;//     FileSource png_source(test_dir / &quot;test_texture.png&quot;);&#10;//     EXPECT_EQ(ResourceType::Texture, png_source.get_type());&#10;//&#10;//     // Test other texture formats&#10;//     create_test_file(&quot;test.jpg&quot;, &quot;fake jpg&quot;);&#10;//     FileSource jpg_source(test_dir / &quot;test.jpg&quot;);&#10;//     EXPECT_EQ(ResourceType::Texture, jpg_source.get_type());&#10;//&#10;//     create_test_file(&quot;test.jpeg&quot;, &quot;fake jpeg&quot;);&#10;//     FileSource jpeg_source(test_dir / &quot;test.jpeg&quot;);&#10;//     EXPECT_EQ(ResourceType::Texture, jpeg_source.get_type());&#10;//&#10;//     create_test_file(&quot;test.hdr&quot;, &quot;fake hdr&quot;);&#10;//     FileSource hdr_source(test_dir / &quot;test.hdr&quot;);&#10;//     EXPECT_EQ(ResourceType::Texture, hdr_source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, DetectsMeshType)&#10;// {&#10;//     FileSource source(test_dir / &quot;test_mesh.obj&quot;);&#10;//     EXPECT_EQ(ResourceType::Mesh, source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, DetectsMaterialType)&#10;// {&#10;//     FileSource source(test_dir / &quot;test_material.mtl&quot;);&#10;//     EXPECT_EQ(ResourceType::Material, source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, DetectsShaderType)&#10;// {&#10;//     FileSource source(test_dir / &quot;test_shader.slang&quot;);&#10;//     EXPECT_EQ(ResourceType::Shader, source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, DetectsCompositeType)&#10;// {&#10;//     FileSource glb_source(test_dir / &quot;test_composite.glb&quot;);&#10;//     EXPECT_EQ(ResourceType::Composite, glb_source.get_type());&#10;//&#10;//     // Test GLTF format too&#10;//     create_test_file(&quot;test.gltf&quot;, &quot;fake gltf&quot;);&#10;//     FileSource gltf_source(test_dir / &quot;test.gltf&quot;);&#10;//     EXPECT_EQ(ResourceType::Composite, gltf_source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, DetectsUnknownType)&#10;// {&#10;//     FileSource source(test_dir / &quot;test_unknown.xyz&quot;);&#10;//     EXPECT_EQ(ResourceType::Unknown, source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, HandlesNonExistentFile)&#10;// {&#10;//     FileSource source(test_dir / &quot;nonexistent.png&quot;);&#10;//     EXPECT_EQ(ResourceType::Unknown, source.get_type());&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, LoadsFileContent)&#10;// {&#10;//     const std::string test_content = &quot;test file content for loading&quot;;&#10;//     create_test_file(&quot;loadtest.txt&quot;, test_content);&#10;//&#10;//     FileSource source(test_dir / &quot;loadtest.txt&quot;);&#10;//     Buffer buffer = source.load();&#10;//&#10;//     ASSERT_NE(nullptr, buffer.data);&#10;//     EXPECT_EQ(test_content.size(), buffer.size);&#10;//&#10;//     // Compare content&#10;//     std::string loaded_content(static_cast&lt;const char*&gt;(buffer.data), buffer.size);&#10;//     EXPECT_EQ(test_content, loaded_content);&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, HandlesEmptyFile)&#10;// {&#10;//     create_test_file(&quot;empty.txt&quot;, &quot;&quot;);&#10;//&#10;//     FileSource source(test_dir / &quot;empty.txt&quot;);&#10;//     Buffer buffer = source.load();&#10;//&#10;//     // Empty file should still return a valid buffer with size 0&#10;//     EXPECT_EQ(0, buffer.size);&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, HandlesNonExistentFileLoad)&#10;// {&#10;//     FileSource source(test_dir / &quot;nonexistent.txt&quot;);&#10;//     Buffer buffer = source.load();&#10;//&#10;//     // Should return empty buffer for non-existent file&#10;//     EXPECT_EQ(nullptr, buffer.data);&#10;//     EXPECT_EQ(0, buffer.size);&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, HandlesLargeFile)&#10;// {&#10;//     // Create a larger test file&#10;//     const size_t large_size = 10000;&#10;//     std::string large_content(large_size, 'A');&#10;//     create_test_file(&quot;large.txt&quot;, large_content);&#10;//&#10;//     FileSource source(test_dir / &quot;large.txt&quot;);&#10;//     Buffer buffer = source.load();&#10;//&#10;//     ASSERT_NE(nullptr, buffer.data);&#10;//     EXPECT_EQ(large_size, buffer.size);&#10;//&#10;//     // Verify first and last characters&#10;//     const char* content = static_cast&lt;const char*&gt;(buffer.data);&#10;//     EXPECT_EQ('A', content[0]);&#10;//     EXPECT_EQ('A', content[large_size - 1]);&#10;// }&#10;//&#10;// TEST_F(FileSourceTest, HandlesPathWithSpaces)&#10;// {&#10;//     create_test_file(&quot;file with spaces.png&quot;, &quot;content&quot;);&#10;//&#10;//     FileSource source(test_dir / &quot;file with spaces.png&quot;);&#10;//     EXPECT_EQ(ResourceType::Texture, source.get_type());&#10;//&#10;//     Buffer buffer = source.load();&#10;//     EXPECT_NE(nullptr, buffer.data);&#10;//     EXPECT_GT(buffer.size, 0);&#10;// }&#10;//&#10;// // Test polymorphism through base class&#10;// TEST_F(FileSourceTest, WorksThroughBaseClass)&#10;// {&#10;//     const std::unique_ptr&lt;ResourceSource&gt; source = std::make_unique&lt;FileSource&gt;(test_dir / &quot;test_texture.png&quot;);&#10;//&#10;//     EXPECT_EQ(ResourceType::Texture, source-&gt;get_type());&#10;//&#10;//     Buffer buffer = source-&gt;load();&#10;//     EXPECT_NE(nullptr, buffer.data);&#10;//     EXPECT_GT(buffer.size, 0);&#10;// }&#10;" />
              <option name="updatedContent" value="//&#13;&#10;// Copyright  2025 Jonatan Nevo.&#13;&#10;// Distributed under the MIT license (see LICENSE file).&#13;&#10;//&#13;&#10;&#13;&#10;#include &lt;gtest/gtest.h&gt;&#13;&#10;#include &lt;gmock/gmock.h&gt;&#13;&#10;#include &lt;filesystem&gt;&#13;&#10;#include &lt;fstream&gt;&#13;&#10;&#13;&#10;#include &quot;portal/engine/resources/source/file_source.h&quot;&#13;&#10;#include &quot;portal/engine/resources/resource_types.h&quot;&#13;&#10;#include &quot;portal/core/buffer.h&quot;&#13;&#10;&#13;&#10;using namespace portal::resources;&#13;&#10;using namespace portal;&#13;&#10;&#13;&#10;class FileSourceTest : public ::testing::Test&#13;&#10;{&#13;&#10;protected:&#13;&#10;    void SetUp() override&#13;&#10;    {&#13;&#10;        // Create temporary test directory&#13;&#10;        test_dir = std::filesystem::temp_directory_path() / &quot;portal_file_source_tests&quot;;&#13;&#10;        std::filesystem::create_directories(test_dir);&#13;&#10;&#13;&#10;        // Create test files with different extensions&#13;&#10;        create_test_file(&quot;test_texture.png&quot;, &quot;fake png data&quot;);&#13;&#10;        create_test_file(&quot;test_mesh.obj&quot;, &quot;fake obj data&quot;);&#13;&#10;        create_test_file(&quot;test_material.mtl&quot;, &quot;fake mtl data&quot;);&#13;&#10;        create_test_file(&quot;test_shader.slang&quot;, &quot;fake slang data&quot;);&#13;&#10;        create_test_file(&quot;test_composite.glb&quot;, &quot;fake glb data&quot;);&#13;&#10;        create_test_file(&quot;test_unknown.xyz&quot;, &quot;unknown file type&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    void TearDown() override&#13;&#10;    {&#13;&#10;        // Clean up test files&#13;&#10;        std::filesystem::remove_all(test_dir);&#13;&#10;    }&#13;&#10;&#13;&#10;    void create_test_file(const std::string&amp; filename, const std::string&amp; content)&#13;&#10;    {&#13;&#10;        auto file_path = test_dir / filename;&#13;&#10;        std::ofstream file(file_path);&#13;&#10;        file &lt;&lt; content;&#13;&#10;    }&#13;&#10;&#13;&#10;    std::filesystem::path test_dir;&#13;&#10;};&#13;&#10;&#13;&#10;// Test resource type detection for various file extensions&#13;&#10;TEST_F(FileSourceTest, DetectsTextureType)&#13;&#10;{&#13;&#10;    FileSource png_source(test_dir / &quot;test_texture.png&quot;);&#13;&#10;    auto meta = png_source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Texture, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Image, meta.format);&#13;&#10;&#13;&#10;    // Test other texture formats&#13;&#10;    create_test_file(&quot;test.jpg&quot;, &quot;fake jpg&quot;);&#13;&#10;    FileSource jpg_source(test_dir / &quot;test.jpg&quot;);&#13;&#10;    meta = jpg_source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Texture, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Image, meta.format);&#13;&#10;&#13;&#10;    create_test_file(&quot;test.jpeg&quot;, &quot;fake jpeg&quot;);&#13;&#10;    FileSource jpeg_source(test_dir / &quot;test.jpeg&quot;);&#13;&#10;    meta = jpeg_source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Texture, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Image, meta.format);&#13;&#10;&#13;&#10;    create_test_file(&quot;test.hdr&quot;, &quot;fake hdr&quot;);&#13;&#10;    FileSource hdr_source(test_dir / &quot;test.hdr&quot;);&#13;&#10;    meta = hdr_source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Texture, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Image, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, DetectsMeshType)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;test_mesh.obj&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Mesh, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Obj, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, DetectsMaterialType)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;test_material.mtl&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Material, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Material, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, DetectsShaderType)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;test_shader.slang&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Shader, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Shader, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, DetectsCompositeType)&#13;&#10;{&#13;&#10;    FileSource glb_source(test_dir / &quot;test_composite.glb&quot;);&#13;&#10;    auto meta = glb_source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Composite, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Glft, meta.format);&#13;&#10;&#13;&#10;    // Test GLTF format too&#13;&#10;    create_test_file(&quot;test.gltf&quot;, &quot;fake gltf&quot;);&#13;&#10;    FileSource gltf_source(test_dir / &quot;test.gltf&quot;);&#13;&#10;    meta = gltf_source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Composite, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Glft, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, DetectsUnknownType)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;test_unknown.xyz&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Unknown, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Unknown, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, HandlesNonExistentFile)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;nonexistent.png&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Unknown, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Unknown, meta.format);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, LoadsFileContent)&#13;&#10;{&#13;&#10;    const std::string test_content = &quot;test file content for loading&quot;;&#13;&#10;    create_test_file(&quot;loadtest.txt&quot;, test_content);&#13;&#10;&#13;&#10;    FileSource source(test_dir / &quot;loadtest.txt&quot;);&#13;&#10;    Buffer buffer = source.load();&#13;&#10;&#13;&#10;    ASSERT_NE(nullptr, buffer.data);&#13;&#10;    EXPECT_EQ(test_content.size(), buffer.size);&#13;&#10;&#13;&#10;    // Compare content&#13;&#10;    std::string loaded_content(static_cast&lt;const char*&gt;(buffer.data), buffer.size);&#13;&#10;    EXPECT_EQ(test_content, loaded_content);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, HandlesEmptyFile)&#13;&#10;{&#13;&#10;    create_test_file(&quot;empty.txt&quot;, &quot;&quot;);&#13;&#10;&#13;&#10;    FileSource source(test_dir / &quot;empty.txt&quot;);&#13;&#10;    Buffer buffer = source.load();&#13;&#10;&#13;&#10;    // Empty file should still return a valid buffer with size 0&#13;&#10;    EXPECT_EQ(0, buffer.size);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, HandlesNonExistentFileLoad)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;nonexistent.txt&quot;);&#13;&#10;    Buffer buffer = source.load();&#13;&#10;&#13;&#10;    // Should return empty buffer for non-existent file&#13;&#10;    EXPECT_EQ(nullptr, buffer.data);&#13;&#10;    EXPECT_EQ(0, buffer.size);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, HandlesLargeFile)&#13;&#10;{&#13;&#10;    // Create a larger test file&#13;&#10;    const size_t large_size = 10000;&#13;&#10;    std::string large_content(large_size, 'A');&#13;&#10;    create_test_file(&quot;large.txt&quot;, large_content);&#13;&#10;&#13;&#10;    FileSource source(test_dir / &quot;large.txt&quot;);&#13;&#10;    Buffer buffer = source.load();&#13;&#10;&#13;&#10;    ASSERT_NE(nullptr, buffer.data);&#13;&#10;    EXPECT_EQ(large_size, buffer.size);&#13;&#10;&#13;&#10;    // Verify first and last characters&#13;&#10;    const char* content = static_cast&lt;const char*&gt;(buffer.data);&#13;&#10;    EXPECT_EQ('A', content[0]);&#13;&#10;    EXPECT_EQ('A', content[large_size - 1]);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, HandlesPathWithSpaces)&#13;&#10;{&#13;&#10;    create_test_file(&quot;file with spaces.png&quot;, &quot;content&quot;);&#13;&#10;&#13;&#10;    FileSource source(test_dir / &quot;file with spaces.png&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Texture, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Image, meta.format);&#13;&#10;&#13;&#10;    Buffer buffer = source.load();&#13;&#10;    EXPECT_NE(nullptr, buffer.data);&#13;&#10;    EXPECT_GT(buffer.size, 0);&#13;&#10;}&#13;&#10;&#13;&#10;// Test polymorphism through base class&#13;&#10;TEST_F(FileSourceTest, WorksThroughBaseClass)&#13;&#10;{&#13;&#10;    const std::unique_ptr&lt;ResourceSource&gt; source = std::make_unique&lt;FileSource&gt;(test_dir / &quot;test_texture.png&quot;);&#13;&#10;&#13;&#10;    auto meta = source-&gt;get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Texture, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Image, meta.format);&#13;&#10;&#13;&#10;    Buffer buffer = source-&gt;load();&#13;&#10;    EXPECT_NE(nullptr, buffer.data);&#13;&#10;    EXPECT_GT(buffer.size, 0);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, ChecksSourceIdFromFilename)&#13;&#10;{&#13;&#10;    FileSource source(test_dir / &quot;test_texture.png&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    &#13;&#10;    // Source ID should be based on the filename&#13;&#10;    EXPECT_EQ(STRING_ID(&quot;test_texture.png&quot;), meta.source_id);&#13;&#10;}&#13;&#10;&#13;&#10;TEST_F(FileSourceTest, HandlesPreprocessedShaderFormat)&#13;&#10;{&#13;&#10;    create_test_file(&quot;shader.spv&quot;, &quot;fake spirv data&quot;);&#13;&#10;    &#13;&#10;    FileSource source(test_dir / &quot;shader.spv&quot;);&#13;&#10;    auto meta = source.get_meta();&#13;&#10;    EXPECT_EQ(ResourceType::Shader, meta.resource_type);&#13;&#10;    EXPECT_EQ(SourceFormat::Preprocessed, meta.format);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/engine/tests/resources/source/resource_source_tests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/engine/tests/resources/source/resource_source_tests.cpp" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>