#[=======================================================================[.rst:
portal_setup_compile_configs
-----------------------------

Generates a single implementation file providing definitions for application configuration
constants declared across all dependent Portal modules.

This function creates a C++ source file that defines compile-time constants for application
metadata (display name, settings file, icon file). These definitions satisfy the ``extern const``
declarations that each Portal module creates via ``portal_setup_config_pch`` in their respective
config PCHs. This allows a single implementation to serve all dependent modules.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_setup_compile_configs(<target_name>
                                <settings_file>
                                <icon_file>)

Arguments
^^^^^^^^^

``<target_name>``
  Name of the executable target to add the configuration definitions to.

``<settings_file>``
  Filename of the settings file (e.g., "settings.json"). Becomes the definition
  for the ``portal::PORTAL_SETTINGS_FILE_NAME`` constant declared in each module's config PCH.

``<icon_file>``
  Filename of the icon file (e.g., "icon.png"). Becomes the definition for
  the ``portal::PORTAL_ICON_FILE_NAME`` constant declared in each module's config PCH.

Behavior
^^^^^^^^

The function performs the following operations:

1. **Template Generation**: Creates a C++ source file template containing definitions
   for ``PORTAL_SETTINGS_FILE_NAME``, and ``PORTAL_ICON_FILE_NAME``
   as ``constexpr std::string_view`` in the ``portal`` namespace.

2. **CMake Configuration**: Writes the template to ``config_impl.inc`` in the build
   directory, then uses ``configure_file()`` to substitute ``@VARIABLE@`` placeholders
   with the provided values, producing ``config_impl.cpp``.

3. **Source Integration**: Adds the generated ``config_impl.cpp`` to the target's
   private sources, providing a single set of definitions that satisfy the declarations
   from all dependent Portal modules.

Multi-Module Declaration Pattern
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Each Portal module (core, application, engine, etc.) that has a config file calls
``portal_setup_config_pch`` during its build, which generates declarations for these
constants in the module's config PCH:

.. code-block:: cpp

  // In portal-application/config.h (also generated by portal_setup_config_pch)
  namespace portal {
      extern constexpr std::string_view PORTAL_SETTINGS_FILE_NAME;
  }

  // In portal-engine/config.h (also generated by portal_setup_config_pch)
  namespace portal {
      extern constexpr std::string_view PORTAL_ICON_FILE_NAME;
  }

The application then calls ``portal_setup_compile_configs`` **once** to provide the single
implementation that all modules will link against:

.. code-block:: cpp

  // In build/config_impl.cpp (generated by portal_setup_compile_configs)
  namespace portal {
      constexpr std::string_view PORTAL_SETTINGS_FILE_NAME = "settings.json";
      constexpr std::string_view PORTAL_ICON_FILE_NAME = "icon.png";
  }

Example Usage
^^^^^^^^^^^^^

Typically called internally by ``portal_add_game()``:

.. code-block:: cmake

  # Each Portal module has already called portal_setup_config_pch during their build
  # Application calls this once to provide the definitions
  portal_setup_compile_configs(my-game "settings.json" "icon.png")

Notes
^^^^^

- This is an internal function typically called by ``portal_add_game()``
- Provides a single implementation for declarations across all dependent Portal modules

See Also
^^^^^^^^

- ``portal_setup_config_pch``: Generates config PCH with variable declarations (called per module)
- ``portal_add_game``: Creates Portal Engine game executables
- ``portal_read_settings``: Reads and processes settings files

#]=======================================================================]
function(portal_setup_compile_configs TARGET_NAME SETTINGS_FILE ICON_FILE)
    set(CONFIGURE_FILE [=[
// Auto generated file

namespace portal
{
    constexpr std::string_view PORTAL_SETTINGS_FILE_NAME = "@SETTINGS_FILE@";
    constexpr std::string_view PORTAL_ICON_FILE_NAME = "@ICON_FILE@";
    constexpr std::string_view PORTAL_ENGINE_LOCATION = "$<TARGET_FILE_DIR:portal::engine>";
};
]=]
    )
    string(REPLACE "@SETTINGS_FILE@" "${SETTINGS_FILE}" CONFIGURE_FILE "${CONFIGURE_FILE}")
    string(REPLACE "@ICON_FILE@" "${ICON_FILE}" CONFIGURE_FILE "${CONFIGURE_FILE}")

    set(OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/${TARGET_NAME}_config_impl_$<CONFIG>.cpp)

    file(GENERATE OUTPUT "${OUTPUT_PATH}" CONTENT "${CONFIGURE_FILE}" TARGET ${TARGET_NAME})
    target_sources(${TARGET_NAME} PRIVATE "${OUTPUT_PATH}")
endfunction()

#[=======================================================================[.rst:
portal_add_resources
--------------------

Adds a resource directory to a target, automatically copying it to the runtime output directory.

This function sets up automatic copying of resource directories (e.g., textures, models, shaders)
to the target's runtime directory structure. Resources are tracked via the ``PORTAL_RESOURCES``
target property, which is used during installation and by ``portal_fetch_resources``.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_add_resources(<target_name> <resource_path>
                       [OUTPUT_NAME <name>])

Arguments
^^^^^^^^^

``<target_name>``
  Name of the target to add resources to.

``<resource_path>``
  Path to the resource directory, relative to ``CMAKE_CURRENT_SOURCE_DIR``.
  All files within this directory will be recursively copied.

``OUTPUT_NAME <name>``
  Optional. The name of the subdirectory under ``resources/`` in the output directory.
  If not specified, uses the base name of ``<resource_path>``.

Behavior
^^^^^^^^

The function performs the following operations:

1. **Resource Discovery**: Recursively finds all files within ``<resource_path>``
   using ``GLOB_RECURSE``.

2. **Custom Target Creation**: Creates a custom target named
   ``<target_name>_copy_resources_<output_name>`` that copies the resource directory to
   ``$<TARGET_FILE_DIR:target>/resources/<output_name>/`` at build time.

3. **Dependency Setup**: Adds the custom target as a dependency of the main target,
   ensuring resources are copied before the executable runs.

4. **Property Tracking**: Appends ``<output_name>`` to the target's ``PORTAL_RESOURCES``
   property and marks it as an exported property for installation.

Example Usage
^^^^^^^^^^^^^

Basic resource addition with automatic output name:

.. code-block:: cmake

  # Copies textures/ to build/resources/textures/
  portal_add_resources(my-game textures)

Resource addition with custom output name:

.. code-block:: cmake

  # Copies game_data/maps/ to build/resources/game-maps/
  portal_add_resources(my-game game_data/maps OUTPUT_NAME game-maps)

Multiple resources for one target:

.. code-block:: cmake

  portal_add_resources(my-game textures)
  portal_add_resources(my-game models)
  portal_add_resources(my-game shaders)
  # Results in: resources/textures/, resources/models/, resources/shaders/

Notes
^^^^^

- Resources are copied to ``$<TARGET_FILE_DIR:target>/resources/<output_name>/``
- The ``PORTAL_RESOURCES`` property is exported for use during installation
- Resources are automatically copied when the target is built
- Use ``portal_fetch_resources`` to copy resources from other Portal targets

See Also
^^^^^^^^

- ``portal_fetch_resources``: Fetch resources from other Portal targets
- ``portal_install_game``: Install game with resources
- ``portal_read_settings``: Read settings file and process resource references

#]=======================================================================]
function(portal_add_resources TARGET_NAME RESOURCE_PATH)
    set(options "")
    set(oneValueArgs OUTPUT_NAME)
    set(multiValueArgs "")
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    get_filename_component(RESOURCE_DIR_NAME "${RESOURCE_PATH}" NAME)

    if (NOT ARG_OUTPUT_NAME)
        set(ARG_OUTPUT_NAME ${RESOURCE_DIR_NAME})
    endif ()

    file(GLOB_RECURSE RESOURCE_FILES
            "${CMAKE_CURRENT_SOURCE_DIR}/${RESOURCE_PATH}/*"
    )

    set(RESOURCE_TARGET_NAME "${TARGET_NAME}_copy_resources_${ARG_OUTPUT_NAME}")

    add_custom_target(${RESOURCE_TARGET_NAME}
            COMMAND ${CMAKE_COMMAND} -E copy_directory
            "${CMAKE_CURRENT_SOURCE_DIR}/${RESOURCE_PATH}"
            "$<TARGET_FILE_DIR:${TARGET_NAME}>/resources/${ARG_OUTPUT_NAME}"
            DEPENDS ${RESOURCE_FILES}
            COMMENT "Copying resources for ${TARGET_NAME}: ${RESOURCE_PATH} -> resources/${ARG_OUTPUT_NAME}"
            VERBATIM
    )

    add_dependencies(${TARGET_NAME} ${RESOURCE_TARGET_NAME})

    get_target_property(EXISTING_RESOURCES ${TARGET_NAME} PORTAL_RESOURCES)
    if (NOT EXISTING_RESOURCES)
        set(EXISTING_RESOURCES "")
    endif ()

    list(APPEND EXISTING_RESOURCES "${ARG_OUTPUT_NAME}")
    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_RESOURCES "${EXISTING_RESOURCES}")
    set_property(TARGET ${TARGET_NAME} APPEND PROPERTY EXPORT_PROPERTIES PORTAL_RESOURCES)
endfunction()


#[=======================================================================[.rst:
portal_add_configs
------------------

Adds a config directory to a target and copies it to the runtime output directory.

This function sets up automatic copying of configuration files to
``$<TARGET_FILE_DIR:target>/config`` and marks the target as having config files
for installation and downstream consumption.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_add_configs(<target_name> <config_path>)

Arguments
^^^^^^^^^

``<target_name>``
  Name of the target to add configs to.

``<config_path>``
  Path to the config directory. If relative, it is interpreted relative to
  ``CMAKE_CURRENT_SOURCE_DIR``. Absolute paths are accepted as-is.

Behavior
^^^^^^^^

The function performs the following operations:

1. **Config Discovery**: Recursively finds all files within ``<config_path>``
   using ``GLOB_RECURSE``.

2. **Custom Target Creation**: Creates a custom target named
   ``<target_name>_copy_configs`` that copies the config directory to
   ``$<TARGET_FILE_DIR:target>/config`` at build time.

3. **Dependency Setup**: Adds the custom target as a dependency of the main target.

4. **Property Tracking**: Sets ``PORTAL_HAS_CONFIG`` on the target and exports it
   for installation and imported target use.

Example Usage
^^^^^^^^^^^^^

.. code-block:: cmake

  portal_add_configs(my-game ${CMAKE_CURRENT_SOURCE_DIR}/config)

Notes
^^^^^

- Configs are copied to ``$<TARGET_FILE_DIR:target>/config``.
- ``PORTAL_HAS_CONFIG`` is used by ``portal_fetch_configs`` and ``portal_install_module``.

See Also
^^^^^^^^

- ``portal_fetch_configs``: Fetch configs from other Portal targets
- ``portal_install_module``: Install module with config prefix

#]=======================================================================]
function(portal_add_configs TARGET_NAME CONFIG_PATH)
    get_filename_component(CONFIG_DIR_NAME "${CONFIG_PATH}" NAME)

    if (IS_ABSOLUTE "${CONFIG_PATH}")
        set(CONFIG_SOURCE_PATH "${CONFIG_PATH}")
    else ()
        set(CONFIG_SOURCE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/${CONFIG_PATH}")
    endif ()

    file(GLOB_RECURSE CONFIG_FILES
            "${CONFIG_SOURCE_PATH}/*"
    )

    set(CONFIG_TARGET_NAME "${TARGET_NAME}_copy_configs")

    add_custom_target(${CONFIG_TARGET_NAME}
            COMMAND ${CMAKE_COMMAND} -E copy_directory
            "${CONFIG_SOURCE_PATH}"
            "$<TARGET_FILE_DIR:${TARGET_NAME}>/config"
            DEPENDS ${CONFIG_FILES}
            COMMENT "Copying configs for ${TARGET_NAME}: ${CONFIG_SOURCE_PATH} -> $<TARGET_FILE_DIR:${TARGET_NAME}>/config"
            VERBATIM
    )

    add_dependencies(${TARGET_NAME} ${CONFIG_TARGET_NAME})

    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_HAS_CONFIG ON)
    set_property(TARGET ${TARGET_NAME} APPEND PROPERTY EXPORT_PROPERTIES PORTAL_HAS_CONFIG)
endfunction()

#[=======================================================================[.rst:
portal_fetch_resources
----------------------

Copies resources from another Portal target (local or installed) to the current target's
runtime directory.

This function enables resource sharing between Portal targets by copying resources from
a dependency target (e.g., ``portal::engine``) to the current target. It works with both
local in-tree targets and installed/imported Portal modules.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_fetch_resources(<target_name> <target_to_fetch>
                         [RESOURCES_TO_FETCH <resource>...])

Arguments
^^^^^^^^^

``<target_name>``
  Name of the target that will receive the fetched resources.

``<target_to_fetch>``
  Name of the Portal target to fetch resources from. Can be either a local
  target or an installed target (e.g., ``portal::engine``, ``portal::core``).

``RESOURCES_TO_FETCH <resource>...``
  Optional. List of specific resource folder names to fetch. If not specified,
  all resources from the target will be fetched. Each resource name must exist
  in the target's ``PORTAL_RESOURCES`` property or an error will be raised.

Behavior
^^^^^^^^

The function performs the following operations:

1. **Resource Validation**: Reads the ``PORTAL_RESOURCES`` property from
   ``<target_to_fetch>``. If specific resources are requested via ``RESOURCES_TO_FETCH``,
   validates that they exist.

2. **Path Resolution**: Determines the resource base path:

   - **Local targets**: Uses ``$<TARGET_FILE_DIR:target_to_fetch>/resources``
   - **Installed targets**: Uses the ``PORTAL_RESOURCE_PREFIX`` property set during
     installation

3. **Custom Target Creation**: For each resource, creates a custom target named
   ``<target_name>_fetch_<resource>_from_<target_to_fetch>`` that copies the resource
   directory to ``$<TARGET_FILE_DIR:target_name>/resources/<resource>/``.

4. **Dependency Chain**: Sets up dependencies to ensure correct build order:

   - Fetch target depends on ``<target_to_fetch>``
   - Fetch target depends on source copy target (if it exists)
   - Main target depends on fetch target

5. **Property Tracking**: Appends fetched resources to the target's
   ``PORTAL_ADDITIONAL_RESOURCES`` property and marks it for export.

Example Usage
^^^^^^^^^^^^^

Fetch all resources from portal-engine:

.. code-block:: cmake

  # Fetches all resources (shaders, fonts, icons, etc.)
  portal_fetch_resources(my-game portal::engine)

Fetch specific resources only:

.. code-block:: cmake

  # Only fetch shaders and fonts, ignore other engine resources
  portal_fetch_resources(my-game portal::engine
                         RESOURCES_TO_FETCH shaders fonts)

Fetch from multiple targets:

.. code-block:: cmake

  portal_fetch_resources(my-game portal::engine)
  portal_fetch_resources(my-game custom-asset-library RESOURCES_TO_FETCH models)

Notes
^^^^^

- Fetched resources are tracked separately via ``PORTAL_ADDITIONAL_RESOURCES``
- The ``PORTAL_RESOURCE_PREFIX`` property is set by ``portal_install_module``
- Target namespace separators (``::``  ) are normalized to underscores for target names
- Errors if the requested resource doesn't exist in the source target

See Also
^^^^^^^^

- ``portal_add_resources``: Add local resources to a target
- ``portal_install_module``: Install Portal modules (sets PORTAL_RESOURCE_PREFIX)
- ``portal_read_settings``: Read settings and process resource references
- ``portal_install_game``: Install game with fetched resources

#]=======================================================================]
function(portal_fetch_resources TARGET_NAME TARGET_TO_FETCH)
    set(options "")
    set(oneValueArgs "")
    set(multiValueArgs RESOURCES_TO_FETCH)
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    get_target_property(TARGET_RESOURCES ${TARGET_TO_FETCH} PORTAL_RESOURCES)
    if (NOT TARGET_RESOURCES)
        message(FATAL_ERROR "Failed to fetch resources from target ${TARGET_TO_FETCH}")
    endif ()

    get_target_property(EXISTING_ADDITIONAL_RESOURCES ${TARGET_NAME} PORTAL_ADDITIONAL_RESOURCES)
    if (NOT EXISTING_ADDITIONAL_RESOURCES)
        set(EXISTING_ADDITIONAL_RESOURCES "")
    endif ()

    set(RESOURCES_TO_COPY ${TARGET_RESOURCES})
    if (ARG_RESOURCES_TO_FETCH)
        # Validate and use only specific resources
        set(RESOURCES_TO_COPY "")
        foreach (RESOURCE_PATH ${ARG_RESOURCES_TO_FETCH})
            if (NOT RESOURCE_PATH IN_LIST TARGET_RESOURCES)
                message(FATAL_ERROR "Resource '${RESOURCE_PATH}' not found in target ${TARGET_TO_FETCH}. Available resources: ${TARGET_RESOURCES}")
            endif ()
            list(APPEND RESOURCES_TO_COPY "${RESOURCE_PATH}")
        endforeach ()
    endif ()

    # Check if the target has a PORTAL_RESOURCE_PREFIX property (for installed targets)
    get_target_property(RESOURCE_PREFIX ${TARGET_TO_FETCH} PORTAL_RESOURCE_PREFIX)
    if (NOT RESOURCE_PREFIX OR RESOURCE_PREFIX STREQUAL "PORTAL_RESOURCE_PREFIX-NOTFOUND")
        # For local targets, use TARGET_FILE_DIR
        set(RESOURCE_BASE_PATH "$<TARGET_FILE_DIR:${TARGET_TO_FETCH}>/resources")
    else ()
        # For installed/imported targets, use the PORTAL_RESOURCE_PREFIX property
        set(RESOURCE_BASE_PATH "${RESOURCE_PREFIX}")
    endif ()

    foreach (RESOURCE_PATH ${RESOURCES_TO_COPY})
        list(APPEND EXISTING_ADDITIONAL_RESOURCES "${RESOURCE_PATH}")

        set(_TARGET_TO_FETCH_NORMALIZED "${TARGET_TO_FETCH}")
        string(REPLACE "::" "_" _TARGET_TO_FETCH_NORMALIZED "${_TARGET_TO_FETCH_NORMALIZED}")

        set(FETCH_TARGET_NAME "${TARGET_NAME}_fetch_${RESOURCE_PATH}_from_${_TARGET_TO_FETCH_NORMALIZED}")

        set(SOURCE_COPY_TARGET "${TARGET_TO_FETCH}_copy_${RESOURCE_PATH}")

        add_custom_target(${FETCH_TARGET_NAME}
                COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${RESOURCE_BASE_PATH}/${RESOURCE_PATH}"
                "$<TARGET_FILE_DIR:${TARGET_NAME}>/resources/${RESOURCE_PATH}"
                COMMENT "Fetching resources for ${TARGET_NAME}: ${TARGET_TO_FETCH}/resources/${RESOURCE_PATH} -> resources/${RESOURCE_PATH}"
                VERBATIM
        )

        if (TARGET ${SOURCE_COPY_TARGET})
            add_dependencies(${FETCH_TARGET_NAME} ${SOURCE_COPY_TARGET})
        endif ()
        add_dependencies(${FETCH_TARGET_NAME} ${TARGET_TO_FETCH})

        add_dependencies(${TARGET_NAME} ${FETCH_TARGET_NAME})
    endforeach ()

    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_ADDITIONAL_RESOURCES "${EXISTING_ADDITIONAL_RESOURCES}")
    set_property(TARGET ${TARGET_NAME} APPEND PROPERTY EXPORT_PROPERTIES PORTAL_ADDITIONAL_RESOURCES)
endfunction()


#[=======================================================================[.rst:
portal_fetch_configs
--------------------

Copies config files from another Portal target (local or installed) to the current target's
runtime directory.

This function enables config sharing between Portal targets by copying the ``config/``
folder from a dependency target (e.g., ``portal::engine``) to the current target. It works
with both local in-tree targets and installed/imported Portal modules.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_fetch_configs(<target_name> <target_to_fetch>)

Arguments
^^^^^^^^^

``<target_name>``
  Name of the target that will receive the fetched config files.

``<target_to_fetch>``
  Name of the Portal target to fetch config files from. Can be either a local
  target or an installed target (e.g., ``portal::engine``, ``portal::core``).

Behavior
^^^^^^^^

The function performs the following operations:

1. **Config Validation**: Reads the ``PORTAL_HAS_CONFIG`` property from
   ``<target_to_fetch>`` and errors if it is not set.

2. **Path Resolution**: Determines the config base path:

   - **Local targets**: Uses ``$<TARGET_FILE_DIR:target_to_fetch>/config``
   - **Installed targets**: Uses the ``PORTAL_CONFIG_PREFIX`` property set during
     installation

3. **Custom Target Creation**: Creates a custom target named
   ``<target_name>_fetch_config_from_<target_to_fetch>`` that copies the config
   directory to ``$<TARGET_FILE_DIR:target_name>/config``.

4. **Dependency Chain**: Ensures correct build order by depending on the source
   copy target (if it exists) and the source target itself.

Example Usage
^^^^^^^^^^^^^

.. code-block:: cmake

  portal_fetch_configs(my-game portal::engine)

Notes
^^^^^

- The ``PORTAL_CONFIG_PREFIX`` property is set by ``portal_install_module``.
- Target namespace separators (``::``) are normalized to underscores for target names.

See Also
^^^^^^^^

- ``portal_add_configs``: Add local config directory to a target
- ``portal_install_module``: Install Portal modules (sets PORTAL_CONFIG_PREFIX)

#]=======================================================================]
function(portal_fetch_configs TARGET_NAME TARGET_TO_FETCH)
    get_target_property(HAS_CONFIG ${TARGET_TO_FETCH} PORTAL_HAS_CONFIG)
    if (NOT HAS_CONFIG)
        message(FATAL_ERROR "Failed to find config from target ${TARGET_TO_FETCH}")
    endif ()

    get_target_property(CONFIG_PREFIX ${TARGET_TO_FETCH} PORTAL_CONFIG_PREFIX)
    if (NOT CONFIG_PREFIX OR CONFIG_PREFIX STREQUAL "PORTAL_CONFIG_PREFIX-NOTFOUND")
        # For local targets, use TARGET_FILE_DIR
        set(CONFIG_BASE_PATH "$<TARGET_FILE_DIR:${TARGET_TO_FETCH}>/config")
    else ()
        # For installed/imported targets, use the PORTAL_RESOURCE_PREFIX property
        set(CONFIG_BASE_PATH "${CONFIG_PREFIX}")
    endif ()

    set(_TARGET_TO_FETCH_NORMALIZED "${TARGET_TO_FETCH}")
    string(REPLACE "::" "_" _TARGET_TO_FETCH_NORMALIZED "${_TARGET_TO_FETCH_NORMALIZED}")

    set(FETCH_TARGET_NAME "${TARGET_NAME}_fetch_config_from_${_TARGET_TO_FETCH_NORMALIZED}")
    set(SOURCE_COPY_TARGET "${TARGET_TO_FETCH}_copy_configs")

    add_custom_target(${FETCH_TARGET_NAME}
            COMMAND ${CMAKE_COMMAND} -E copy_directory
            "${CONFIG_BASE_PATH}"
            "$<TARGET_FILE_DIR:${TARGET_NAME}>/config"
            COMMENT "Fetching configs for ${TARGET_NAME}: ${CONFIG_BASE_PATH} -> $<TARGET_FILE_DIR:${TARGET_NAME}>/config"
            VERBATIM
    )

    if (TARGET ${SOURCE_COPY_TARGET})
        add_dependencies(${FETCH_TARGET_NAME} ${SOURCE_COPY_TARGET})
    endif ()
    add_dependencies(${FETCH_TARGET_NAME} ${TARGET_TO_FETCH})

    add_dependencies(${TARGET_NAME} ${FETCH_TARGET_NAME})
endfunction()

#[=======================================================================[.rst:
portal_read_settings
--------------------

Reads and processes a Portal Engine settings file, configuring the target based on its
contents and preparing it for installation.

This function reads a JSON settings file, extracts engine configuration and resource
references, sets up automatic resource copying, and configures the settings file as
an install target for deployment.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_read_settings(<target_name>)

Arguments
^^^^^^^^^

``<target_name>``
  Name of the target to configure. The target must have the ``PORTAL_SETTINGS_PATH``
  property set (typically by ``portal_add_game``).

Behavior
^^^^^^^^

The function performs the following operations:

1. **Settings Validation**: Retrieves the settings file path from the target's
   ``PORTAL_SETTINGS_PATH`` property and validates that the file exists.

2. **Installation Setup**: Creates a custom command to copy the settings file to
   ``$<TARGET_FILE_DIR:target>/<filename>`` using ``copy_if_different`` for
   efficient incremental builds.

3. **Display Name**: Reads ``project.name`` from the settings JSON to set the
   ``PORTAL_DISPLAY_NAME`` target property, defaulting to the target name on error.

4. **Configuration Parsing**: Reads and parses the JSON settings file to extract
   resource entries from ``project.resources``.

5. **Resource Configuration**: For each resource entry in the settings:

   - Extracts the ``type`` and ``path`` fields from the resource object
   - Validates that the path is relative (absolute paths are skipped)
   - Creates custom targets to copy resource directories to the runtime output
   - Registers resources with the ``PORTAL_RESOURCES`` property for installation

6. **Target Dependencies**: Ensures the settings file and resources are copied
   during the build process by adding appropriate target dependencies.


Example Usage
^^^^^^^^^^^^^

Typically called internally by ``portal_add_game()``:

.. code-block:: cmake

  # Set the settings path property
  set_target_properties(my-game PROPERTIES
      PORTAL_SETTINGS_PATH "${CMAKE_CURRENT_SOURCE_DIR}/settings.json")

  # Read, configure, and prepare for installation
  portal_read_settings(my-game)

Notes
^^^^^

- This is an internal function typically called by ``portal_add_game()``
- Uses ``copy_if_different`` to avoid unnecessary rebuilds
- Only relative resource paths are processed
- Resources are tracked via ``PORTAL_RESOURCES`` for installation
- TODO: Future versions will validate engine version compatibility

See Also
^^^^^^^^

- ``portal_add_game``: Creates Portal Engine game executables
- ``portal_install_game``: Install game with settings and resources
- ``portal_add_resources``: Manually add resource directories

#]=======================================================================]
function(portal_read_settings TARGET_NAME)
    get_target_property(SETTINGS_PATH ${TARGET_NAME} PORTAL_SETTINGS_PATH)

    if (NOT EXISTS ${SETTINGS_PATH})
        message(FATAL_ERROR "Failed to find settings in ${SETTINGS_PATH}")
    endif ()

    # TODO: validate engine version matches what in the json

    cmake_path(GET SETTINGS_PATH FILENAME SETTINGS_FILENAME)
    set(SETTINGS_OUTPUT_PATH "$<TARGET_FILE_DIR:${TARGET_NAME}>/${SETTINGS_FILENAME}")

    set(SETTINGS_COPY_TARGET_NAME "${TARGET_NAME}_copy_settings")
    add_custom_command(
            OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${SETTINGS_FILENAME}
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
            "${SETTINGS_PATH}"
            "${SETTINGS_OUTPUT_PATH}"
            DEPENDS ${SETTINGS_PATH}
            COMMENT "Copying settings file for ${TARGET_NAME}: ${SETTINGS_FILENAME}"
            VERBATIM
    )
    add_custom_target(${SETTINGS_COPY_TARGET_NAME} DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${SETTINGS_FILENAME})
    add_dependencies(${TARGET_NAME} ${SETTINGS_COPY_TARGET_NAME})

    file(READ ${SETTINGS_PATH} SETTINGS_CONTENT)

    # Read Name
    string(JSON PROJECT_NAME ERROR_VARIABLE JSON_ERROR GET ${SETTINGS_CONTENT} project name)
    if (JSON_ERROR)
        message(STATUS "Error reading project name from settings: ${JSON_ERROR}, defaulting to target name")
        set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_DISPLAY_NAME ${TARGET_NAME})
    else ()
        set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_DISPLAY_NAME ${PROJECT_NAME})
    endif ()


    # Read Resources
    string(JSON RESOURCES_LIST_LENGTH LENGTH ${SETTINGS_CONTENT} project resources)
    if (RESOURCES_LIST_LENGTH GREATER 0)
        math(EXPR RESOURCES_LIST_LAST_INDEX "${RESOURCES_LIST_LENGTH} - 1")
        foreach (IDX RANGE ${RESOURCES_LIST_LAST_INDEX})
            string(JSON RESOURCE_OBJECT GET "${SETTINGS_CONTENT}" project resources ${IDX})
            string(JSON RESOURCE_TYPE GET ${RESOURCE_OBJECT} type)
            string(JSON RESOURCE_PATH GET ${RESOURCE_OBJECT} path)

            cmake_path(IS_RELATIVE RESOURCE_PATH IS_RELATIVE_VAR)

            if (IS_RELATIVE_VAR)
                file(GLOB_RECURSE RESOURCE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/${RESOURCE_PATH}/*")
                set(RESOURCE_TARGET_NAME "${TARGET_NAME}_copy_settings_${RESOURCE_PATH}")

                add_custom_target(${RESOURCE_TARGET_NAME}
                        COMMAND ${CMAKE_COMMAND} -E copy_directory
                        "${CMAKE_CURRENT_SOURCE_DIR}/${RESOURCE_PATH}"
                        "$<TARGET_FILE_DIR:${TARGET_NAME}>/resources/${RESOURCE_PATH}"
                        DEPENDS ${RESOURCE_FILES} ${SETTINGS_PATH}
                        COMMENT "Copying resources form ${TARGET_NAME} settings: ${RESOURCE_PATH} -> resources/${ARG_OUTPUT_NAME}"
                        VERBATIM
                )

                add_dependencies(${TARGET_NAME} ${RESOURCE_TARGET_NAME})
                set_property(TARGET ${TARGET_NAME} APPEND PROPERTY PORTAL_RESOURCES ${RESOURCE_PATH})
            else ()
                message(STATUS "Found absolute resource path, skipping... ${RESOURCE_PATH}")
            endif ()
        endforeach ()
    endif ()
endfunction()

#[=======================================================================[.rst:
portal_install_game
-------------------

Configures installation rules for a Portal Engine game executable with platform-specific
runtime dependency handling.

This function sets up comprehensive installation rules for game executables, including
the binary, runtime dependencies (DLLs/shared libraries), settings files, and resources.
It handles platform-specific RPATH configuration and excludes system libraries appropriately.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_install_game(<target_name>)

Arguments
^^^^^^^^^

``<target_name>``
  Name of the game executable target to install.

Behavior
^^^^^^^^

The function performs the following operations:

1. **Executable Installation**: Installs the target binary and creates a runtime
   dependency set for automatic dependency resolution.

2. **Platform-Specific RPATH** (Linux/macOS)

3. **Runtime Dependency Installation**

4. **Settings File Installation**: If the target has a ``PORTAL_SETTINGS_PATH`` property,
   installs ``settings.json`` to the root installation directory.

5. **Resource Installation**: Installs all resources from both ``PORTAL_RESOURCES``
   (added via ``portal_add_resources``) and ``PORTAL_ADDITIONAL_RESOURCES``
   (added via ``portal_fetch_resources``) to ``resources/``.

Installation Layout
^^^^^^^^^^^^^^^^^^^

The installed game directory structure:

.. code-block:: text

  install/
    ├── <executable>          # Game binary (Windows/Linux)
    ├── <executable>.app/     # macOS bundle (if MAKE_STANDALONE)
    ├── settings.json         # Settings file (if present)
    ├── lib/                  # Shared libraries (Linux/macOS)
    │   ├── libvulkan.so.1
    │   └── ...
    └── resources/            # Game resources
        ├── textures/
        ├── models/
        └── ...

On Windows, DLLs are installed in the root alongside the executable.

Example Usage
^^^^^^^^^^^^^

Typically called internally by ``portal_add_game()``:

.. code-block:: cmake

  portal_install_game(my-game)

Install the game manually:

.. code-block:: bash

  cmake --install build/ninja-multi --component my-game

Notes
^^^^^

- This is an internal function typically called by ``portal_add_game()``
- Uses CMake's ``RUNTIME_DEPENDENCY_SET`` for automatic dependency discovery
- Resources from both ``PORTAL_RESOURCES`` and ``PORTAL_ADDITIONAL_RESOURCES`` are installed

See Also
^^^^^^^^

- ``portal_add_game``: Creates Portal Engine game executables
- ``portal_package_game``: Package game for distribution with CPack
- ``portal_add_resources``: Add local resources
- ``portal_fetch_resources``: Fetch resources from dependencies

#]=======================================================================]
function(portal_install_game TARGET_NAME)
    set(options "")
    set(oneValueArgs "")
    set(multiValueArgs "")
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    install(
            TARGETS ${TARGET_NAME}
            COMPONENT ${TARGET_NAME}
            RUNTIME_DEPENDENCY_SET ${TARGET_NAME}_deps
            RUNTIME
            DESTINATION .
            BUNDLE
            DESTINATION .
    )

    message(STATUS "Vcpkg Installed Dir ${VCPKG_INSTALLED_DIR}")

    if (WIN32)
        install(
                RUNTIME_DEPENDENCY_SET ${TARGET_NAME}_deps
                PRE_EXCLUDE_REGEXES
                # Windows API Set DLLs
                "api-ms-win-.*" "ext-ms-.*"
                POST_EXCLUDE_REGEXES
                # Windows system directories
                ".*[Ss]ystem32/.*\\.dll" ".*[Ww]in[Ss]x[Ss]/.*\\.dll"
                DIRECTORIES
                $<TARGET_FILE_DIR:${TARGET_NAME}>
                ${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/lib
                ${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/bin
                COMPONENT ${TARGET_NAME}
                DESTINATION .
        )
    else ()
        if (APPLE)
            set_target_properties(${TARGET_NAME} PROPERTIES
                    BUILD_RPATH "@executable_path/${TARGET_NAME}.app/Contents/Frameworks"
                    BUILD_WITH_INSTALL_RPATH FALSE
            )
        elseif (UNIX)
            set_target_properties(${TARGET_NAME} PROPERTIES
                    INSTALL_RPATH "$ORIGIN/lib"
                    BUILD_RPATH "${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/lib"
                    BUILD_WITH_INSTALL_RPATH FALSE
            )
        endif ()

        install(
                RUNTIME_DEPENDENCY_SET ${TARGET_NAME}_deps
                PRE_EXCLUDE_REGEXES
                # Common system libraries (all platforms)
                "libc\\.so.*" "libm\\.so.*" "libpthread\\.so.*" "libdl\\.so.*"
                "librt\\.so.*" "libgcc_s\\.so.*" "libstdc\\+\\+\\.so.*"
                "ld-linux.*\\.so.*" "libSystem\\..*dylib" "libc\\+\\+\\..*dylib"
                POST_EXCLUDE_REGEXES
                # Linux system directories
                "^/lib/.*\\.so.*" "^/lib64/.*\\.so.*"
                ".*/usr/lib/.*\\.so.*" ".*/usr/lib64/.*\\.so.*"
                # macOS system directories
                ".*/System/Library/.*" ".*/usr/lib/.*\\.dylib"
                DIRECTORIES
                $<TARGET_FILE_DIR:${TARGET_NAME}>
                ${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/lib
                ${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/bin
                COMPONENT ${TARGET_NAME}
                DESTINATION lib
        )
    endif ()

    set(FILES_TO_INSTALL "")

    get_target_property(SETTINGS_PATH ${TARGET_NAME} PORTAL_SETTINGS_PATH)
    if (SETTINGS_PATH)
        list(APPEND FILES_TO_INSTALL "${CMAKE_CURRENT_SOURCE_DIR}/settings.json")
    endif ()

    if (FILES_TO_INSTALL)
        install(
                FILES ${FILES_TO_INSTALL}
                COMPONENT ${TARGET_NAME}
                DESTINATION .
        )
    endif ()


    get_target_property(RESOURCES_FOLDERS ${TARGET_NAME} PORTAL_RESOURCES)
    if (NOT RESOURCES_FOLDERS OR RESOURCES_FOLDERS STREQUAL "PORTAL_RESOURCES-NOTFOUND")
        set(RESOURCES_FOLDERS "")
    endif ()

    foreach (RESOURCE_FOLDER IN LISTS RESOURCES_FOLDERS)
        install(
                DIRECTORY "$<TARGET_FILE_DIR:${TARGET_NAME}>/resources/${RESOURCE_FOLDER}"
                COMPONENT ${TARGET_NAME}
                DESTINATION resources
        )
    endforeach ()

    get_target_property(ADDITIONAL_RESOURCES_FOLDERS ${TARGET_NAME} PORTAL_ADDITIONAL_RESOURCES)
    if (NOT ADDITIONAL_RESOURCES_FOLDERS OR ADDITIONAL_RESOURCES_FOLDERS STREQUAL "PORTAL_ADDITIONAL_RESOURCES-NOTFOUND")
        set(ADDITIONAL_RESOURCES_FOLDERS "")
    endif ()

    foreach (RESOURCE_FOLDER IN LISTS ADDITIONAL_RESOURCES_FOLDERS)
        install(
                DIRECTORY "$<TARGET_FILE_DIR:${TARGET_NAME}>/resources/${RESOURCE_FOLDER}"
                COMPONENT ${TARGET_NAME}
                DESTINATION resources
        )
    endforeach ()
endfunction()

#[=======================================================================[.rst:
portal_package_game
-------------------

Configures CPack packaging for a Portal Engine game executable.

This function sets up CPack configuration to create distributable packages
(installers, archives, etc.) for the game. It registers the game as a CPack
component with metadata for package generation.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_package_game(<target_name> <display_name>
                      [VENDOR <vendor>]
                      [CONTACT <contact>])

Arguments
^^^^^^^^^

``<target_name>``
  Name of the game executable target to package.

``<display_name>``
  Human-readable name for the package (e.g., "My Awesome Game").

``VENDOR <vendor>``
  Optional. Vendor/publisher name for the package (e.g., "Some Games Company Inc.").

``CONTACT <contact>``
  Optional. Contact information for the package maintainer.

Behavior
^^^^^^^^

The function performs the following operations:

1. **CPack Inclusion**: Includes the CPack module to enable packaging functionality.

2. **Package Configuration**: Sets CPack variables:

   - ``CPACK_PACKAGE_NAME``: Set to ``<display_name>``
   - ``CPACK_PACKAGE_VENDOR``: Set to ``<vendor>`` if provided
   - ``CPACK_PACKAGE_INSTALL_DIRECTORY``: Set to ``<display_name>``
   - ``CPACK_VERBATIM_VARIABLES``: Enabled for consistent behavior
   - ``CPACK_COMPONENTS_GROUPING``: Set to ``IGNORE`` for flat component structure

3. **Component Registration**: Adds the target as a required CPack component
   with the project name as its display name.

Example Usage
^^^^^^^^^^^^^

Typically called internally by ``portal_add_game()``:

.. code-block:: cmake

  portal_package_game(my-game "My Awesome Game"
                      VENDOR "Some Games Company Inc."
                      CONTACT "support@some_game_company.com")

Notes
^^^^^

- This is an internal function typically called by ``portal_add_game()``
- Requires ``portal_install_game`` to be called first for proper installation rules
- The actual package format depends on the platform and available generators

See Also
^^^^^^^^

- ``portal_add_game``: Creates Portal Engine game executables
- ``portal_install_game``: Sets up installation rules for the game

#]=======================================================================]
function(portal_package_game TARGET_NAME DISPLAY_NAME)
    set(options "")
    set(oneValueArgs
            VENDOR
            CONTACT
    )
    set(multiValueArgs "")
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})


    include(CPack)
    set(CPACK_PACKAGE_NAME ${DISPLAY_NAME})
    set(CPACK_PACKAGE_VENDOR ${ARG_VENDOR})
    set(CPACK_PACKAGE_INSTALL_DIRECTORY ${CPACK_PACKAGE_NAME})
    set(CPACK_VERBATIM_VARIABLES YES)

    set(CPACK_COMPONENTS_GROUPING IGNORE)

    cpack_add_component(${TARGET_NAME}
            REQUIRED
            DISPLAY_NAME ${CMAKE_PROJECT_NAME}
    )
endfunction()

#[=======================================================================[.rst:
_find_icon_files
----------------

Resolves platform-specific icon files and a logo image for a game target.

This macro locates ``.icns``, ``.ico``, and ``.png`` icon files based on a base
path and falls back to Portal Engine defaults when files are missing. It also
resolves the logo PNG file with a default fallback.

Synopsis
^^^^^^^^

.. code-block:: cmake

  _find_icon_files(<static_icon_base> <logo_file>)

Arguments
^^^^^^^^^

``<static_icon_base>``
  Base path (without extension) for icon files. The macro checks for
  ``.icns``, ``.ico``, and ``.png`` variants.

``<logo_file>``
  Path to a logo PNG file. If missing or empty, a Portal Engine default is used.

Outputs
^^^^^^^

The macro sets the following variables in the caller's scope:

- ``ICON_ICNS_FILE``: Path to the macOS icon file
- ``ICON_ICO_FILE``: Path to the Windows icon file
- ``ICON_PNG_FILE``: Path to the PNG icon file
- ``LOGO_PNG_FILE``: Path to the logo PNG file

Notes
^^^^^

- Defaults are sourced from ``portal::engine`` resources when available.
- This is an internal helper macro used by ``portal_add_game``.

#]=======================================================================]
macro(_find_icon_files STATIC_ICON LOGO_FILE)
    # Get the resource prefix from portal-engine for default icons
    get_target_property(ENGINE_RESOURCE_PREFIX portal::engine PORTAL_RESOURCE_PREFIX)
    if (NOT ENGINE_RESOURCE_PREFIX OR ENGINE_RESOURCE_PREFIX STREQUAL "ENGINE_RESOURCE_PREFIX-NOTFOUND")
        # Fallback for local builds (not installed)
        set(ENGINE_RESOURCE_PREFIX "${CMAKE_SOURCE_DIR}/engine/resources")
    else ()
        # For installed targets, append the engine folder
        set(ENGINE_RESOURCE_PREFIX "${ENGINE_RESOURCE_PREFIX}/engine")
    endif ()

    if (STATIC_ICON)
        cmake_path(REPLACE_EXTENSION STATIC_ICON "icns" OUTPUT_VARIABLE ICNS_FILE_CHECK)
        cmake_path(REPLACE_EXTENSION STATIC_ICON "ico" OUTPUT_VARIABLE ICO_FILE_CHECK)
        cmake_path(REPLACE_EXTENSION STATIC_ICON "png" OUTPUT_VARIABLE PNG_FILE_CHECK)
    else ()
        set(ICNS_FILE_CHECK "")
        set(ICO_FILE_CHECK "")
        set(PNG_FILE_CHECK "")
    endif ()

    if (NOT LOGO_FILE)
        set(LOGO_FILE "")
    endif ()

    if (EXISTS "${ICNS_FILE_CHECK}")
        set(ICON_ICNS_FILE "${ICNS_FILE_CHECK}")
        message(STATUS "Using MacOS Icon: ${ICON_ICNS_FILE}")
    else ()
        set(ICON_ICNS_FILE "${ENGINE_RESOURCE_PREFIX}/portal_icon_64x64.icns")
        message(STATUS "Missing MacOS Icon, defaulting to: ${ICON_ICNS_FILE}")
    endif ()

    if (EXISTS "${ICO_FILE_CHECK}")
        set(ICON_ICO_FILE "${ICO_FILE_CHECK}")
        message(STATUS "Using Windows Icon: ${ICON_ICO_FILE}")
    else ()
        set(ICON_ICO_FILE "${ENGINE_RESOURCE_PREFIX}/portal_icon_64x64.ico")
        message(STATUS "Missing Windows Icon, defaulting to: ${ICON_ICO_FILE}")
    endif ()

    if (EXISTS "${PNG_FILE_CHECK}")
        set(ICON_PNG_FILE "${PNG_FILE_CHECK}")
        message(STATUS "Using png Icon: ${ICON_PNG_FILE}")
    else ()
        set(ICON_PNG_FILE "${ENGINE_RESOURCE_PREFIX}/portal_icon_64x64.png")
        message(STATUS "Missing png Icon, defaulting to: ${ICON_PNG_FILE}")
    endif ()

    if (EXISTS "${LOGO_FILE}")
        set(LOGO_PNG_FILE "${LOGO_FILE}")
        message(STATUS "Using Logo: ${LOGO_FILE}")
    else ()
        set(LOGO_PNG_FILE "${ENGINE_RESOURCE_PREFIX}/portal_logo_dark.png")
        message(STATUS "Missing Logo, defaulting to: ${LOGO_PNG_FILE}")
    endif ()
endmacro()

#[=======================================================================[.rst:
portal_add_game
---------------

Creates a complete Portal Engine game executable plus a companion editor target with
automatic resource management, settings configuration, installation, and packaging
for the runtime target.

This is the main entry point for creating game applications with the Portal Engine.
It orchestrates runtime and editor executable creation, icon/logo resolution, resource
fetching, settings processing, and automatic installation/packaging setup for the
runtime target.

Synopsis
^^^^^^^^

.. code-block:: cmake

  portal_add_game(<target_name>
                  SOURCES <source>...
                  [MAKE_STANDALONE]
                  [NO_CONFIG]
                  [SETTINGS_FILE <path>]
                  [SETTINGS_FILE_NAME <filename>]
                  [STATIC_ICON <path>]
                  [LOGO_FILE <path>]
                  [RESOURCE_PATHS <path>...]
                  [LINK_LIBRARIES <library>...]
                  [VENDOR <vendor>]
                  [CONTACT <contact>])

Arguments
^^^^^^^^^

``<target_name>``
  Name of the game executable target to create.

``SOURCES <source>...``
  Required. List of source files for the game executable.

``MAKE_STANDALONE``
  Optional flag. Creates a standalone application:

  - **Windows**: Creates a WIN32 subsystem executable (no console window)
  - **macOS**: Creates a MACOSX_BUNDLE with proper bundle structure
  - **Linux**: No effect (standard executable)

``NO_CONFIG``
  Optional flag. Skips adding the local ``config/`` directory via
  ``portal_add_configs``. Configs from dependencies (e.g., ``portal::engine``)
  are still fetched.

``SETTINGS_FILE <path>``
  Optional. Path to the settings JSON file. If not specified, defaults to
  ``${CMAKE_CURRENT_SOURCE_DIR}/<settings_file_name>``.

``SETTINGS_FILE_NAME <filename>``
  Optional. Name of the settings file. Defaults to ``settings.json``.

``STATIC_ICON <path>``
  Optional. Base path for platform-specific icon files (without extension).
  The function will look for:

  - ``.icns`` (macOS)
  - ``.ico`` (Windows)
  - ``.png`` (Linux/fallback)

  If not found, defaults to Portal Engine icons.

``LOGO_FILE <path>``
  Optional. Path to the logo PNG file. Defaults to Portal Engine logo if not provided.

``RESOURCE_PATHS <path>...``
  Optional. List of local resource directories to add via ``portal_add_resources``.

``LINK_LIBRARIES <library>...``
  Optional. Additional libraries to link beyond ``portal::engine``.

``VENDOR <vendor>``
  Optional. Vendor/publisher name for CPack packaging.

``CONTACT <contact>``
  Optional. Contact information for CPack packaging.

Behavior
^^^^^^^^

The function performs the following operations in order:

1. **Argument Defaults**: Sets default values for ``SETTINGS_FILE_NAME``
   ("settings.json") and initializes icon/logo inputs when not provided.

2. **Executable Creation**:

   - **Runtime target**: Uses MACOSX_BUNDLE or WIN32 when ``MAKE_STANDALONE`` is set,
     otherwise creates a standard console executable
   - **Editor target**: Always creates ``<target_name>_editor`` as a standard console
     executable using the same sources

3. **Icon Resolution**: Calls ``_find_icon_files`` to locate platform-specific
   icons or use Portal Engine defaults, then sets target properties on both targets:

   - ``PORTAL_WINDOWS_ICON``: Path to .ico file
   - ``PORTAL_MACOS_ICON``: Path to .icns file
   - ``PORTAL_LOGO``: Path to logo PNG

4. **Standalone Define**: If ``MAKE_STANDALONE`` is set, defines
   ``PORTAL_STANDALONE_EXE`` for the runtime target.

5. **Editor Define**: Defines ``PORTAL_BUILD_EDITOR`` for ``<target_name>_editor``.

6. **Linking**: Links both targets against ``portal::engine`` and any additional libraries.

7. **Settings Configuration** (runtime target only):

   - Resolves and validates the settings file path
   - Sets ``PORTAL_SETTINGS_PATH`` on the target
   - Calls ``portal_read_settings`` to parse settings and set ``PORTAL_DISPLAY_NAME``

8. **macOS Bundle Properties**: If ``MAKE_STANDALONE`` is set, configures bundle
   metadata using the resolved display name.

9. **Engine Assets**: Fetches Portal Engine resources and configs via
   ``portal_fetch_resources`` and ``portal_fetch_configs``.

10. **Local Resources**: Adds user-specified resource paths via
   ``portal_add_resources``.

11. **Local Configs**: Adds the local ``config/`` directory via
    ``portal_add_configs`` unless ``NO_CONFIG`` is set.

12. **Config Definitions**: Calls ``portal_setup_compile_configs`` to generate
    compile-time configuration constants for both runtime and editor targets.

13. **Installation**: Calls ``portal_install_game`` to set up installation rules.

14. **Packaging**: Calls ``portal_package_game`` to configure CPack.

Target Properties Set
^^^^^^^^^^^^^^^^^^^^^

The function sets the following target properties on the runtime target:

- ``PORTAL_WINDOWS_ICON``: Windows .ico file path
- ``PORTAL_MACOS_ICON``: macOS .icns file path
- ``PORTAL_LOGO``: Logo PNG file path
- ``PORTAL_SETTINGS_PATH``: Settings JSON file path
- ``PORTAL_DISPLAY_NAME``: Display name parsed from the settings file
- ``PORTAL_RESOURCES``: List of resource directories (via ``portal_read_settings``)
- ``PORTAL_ADDITIONAL_RESOURCES``: Fetched resources (via ``portal_fetch_resources``)

The function also creates ``<target_name>_editor`` and sets:

- ``PORTAL_WINDOWS_ICON``: Windows .ico file path
- ``PORTAL_MACOS_ICON``: macOS .icns file path
- ``PORTAL_LOGO``: Logo PNG file path

The editor target defines ``PORTAL_BUILD_EDITOR`` but does not receive settings,
resource/config copy targets, installation, or packaging.

macOS Bundle Properties (MAKE_STANDALONE only):

- ``MACOSX_BUNDLE``: TRUE
- ``MACOSX_BUNDLE_IDENTIFIER``: com.portal.<target_name>
- ``MACOSX_BUNDLE_BUNDLE_NAME``: Display name
- ``MACOSX_BUNDLE_ICON_FILE``: Icon filename
- ``MACOSX_BUNDLE_BUNDLE_VERSION``: Project version
- ``MACOSX_BUNDLE_SHORT_VERSION_STRING``: Project version

Example Usage
^^^^^^^^^^^^^

Minimal game with default settings:

.. code-block:: cmake

  portal_add_game(my-game
                  SOURCES main.cpp game.cpp)

Full-featured standalone game with custom icons and resources:

.. code-block:: cmake

  portal_add_game(awesome-game
                  SOURCES src/main.cpp src/game.cpp src/player.cpp
                  MAKE_STANDALONE
                  STATIC_ICON "${CMAKE_CURRENT_SOURCE_DIR}/icons/game_icon"
                  LOGO_FILE "${CMAKE_CURRENT_SOURCE_DIR}/icons/logo.png"
                  SETTINGS_FILE "${CMAKE_CURRENT_SOURCE_DIR}/config/game_settings.json"
                  RESOURCE_PATHS textures models sounds
                  LINK_LIBRARIES my-game-logic-lib
                  VENDOR "Awesome Games Inc."
                  CONTACT "support@awesomegames.com")

This will:

- Create a standalone runtime executable (no console on Windows, bundle on macOS)
- Create a companion ``awesome-game_editor`` console executable for tooling
- Use custom icons (or fallback to defaults)
- Link against portal-engine and my-game-logic-lib
- Fetch Portal Engine resources (shaders, fonts, etc.)
- Add local resources from textures/, models/, and sounds/
- Process and copy game_settings.json
- Set up complete installation and packaging

Notes
^^^^^

- Always links both targets against ``portal::engine``
- Automatically fetches Portal Engine resources for the runtime target
- Settings file is required and must exist
- Icons default to Portal Engine branding if not provided
- ``MAKE_STANDALONE`` is recommended for distribution builds
- Use ``NO_CONFIG`` to opt out of copying a local ``config/`` directory
- The editor target is build-only and not installed or packaged

See Also
^^^^^^^^

- ``portal_setup_compile_configs``: Generates configuration constants
- ``portal_add_resources``: Add local resource directories
- ``portal_fetch_resources``: Fetch resources from other targets
- ``portal_read_settings``: Process settings file
- ``portal_install_game``: Set up installation rules
- ``portal_package_game``: Configure CPack packaging

#]=======================================================================]

macro(_portal_configure_runtime_target)
    if (APPLE AND ARG_MAKE_STANDALONE)
        cmake_path(GET ICON_ICNS_FILE FILENAME BUNDLE_ICON_FILE)
        set_source_files_properties(${ARG_STATIC_ICON} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources")

        add_executable(${TARGET_NAME} MACOSX_BUNDLE ${ARG_SOURCES} ${ARG_STATIC_ICON})
    elseif (WIN32)
        if (ARG_MAKE_STANDALONE)
            add_executable(${TARGET_NAME} WIN32 ${ARG_SOURCES})
        else ()
            add_executable(${TARGET_NAME} ${ARG_SOURCES})
        endif ()
    else ()
        add_executable(${TARGET_NAME} ${ARG_SOURCES})
    endif ()

    _find_icon_files(ARG_STATIC_ICON ARG_LOGO_FILE)
    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_WINDOWS_ICON ${ICON_ICO_FILE})
    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_MACOS_ICON ${ICON_ICNS_FILE})
    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_LOGO ${LOGO_PNG_FILE})

    if (ARG_MAKE_STANDALONE)
        target_compile_definitions(${TARGET_NAME} PRIVATE PORTAL_STANDALONE_EXE)
    endif ()

    target_link_libraries(
            ${TARGET_NAME}
            portal::engine
            ${ARG_LINK_LIBRARIES}
    )
endmacro()

macro(_portal_configure_editor_target)
    add_executable(${TARGET_NAME}_editor ${ARG_SOURCES})

    _find_icon_files(ARG_STATIC_ICON ARG_LOGO_FILE)
    set_target_properties(${TARGET_NAME}_editor PROPERTIES PORTAL_WINDOWS_ICON ${ICON_ICO_FILE})
    set_target_properties(${TARGET_NAME}_editor PROPERTIES PORTAL_MACOS_ICON ${ICON_ICNS_FILE})
    set_target_properties(${TARGET_NAME}_editor PROPERTIES PORTAL_LOGO ${LOGO_PNG_FILE})

    target_link_libraries(
            ${TARGET_NAME}_editor
            portal::engine
            ${ARG_LINK_LIBRARIES}
    )
    target_compile_definitions(${TARGET_NAME}_editor PRIVATE PORTAL_BUILD_EDITOR)
endmacro()

function(portal_add_game TARGET_NAME)
    set(options MAKE_STANDALONE NO_CONFIG)
    set(oneValueArgs
            SETTINGS_FILE
            STATIC_ICON
            LOGO_FILE
            SETTINGS_FILE_NAME
            VENDOR
            CONTACT
    )
    set(multiValueArgs
            SOURCES
            RESOURCE_PATHS
            LINK_LIBRARIES
    )
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    if (NOT ARG_SETTINGS_FILE_NAME)
        set(ARG_SETTINGS_FILE_NAME "settings.json")
    endif ()

    if (NOT ARG_STATIC_ICON)
        set(ARG_STATIC_ICON "")
    endif ()

    if (NOT ARG_LOGO_FILE)
        set(ARG_LOGO_FILE "")
    endif ()

    _portal_configure_runtime_target()
    _portal_configure_editor_target()

    if (NOT ARG_SETTINGS_FILE)
        set(ARG_SETTINGS_FILE "${CMAKE_CURRENT_SOURCE_DIR}/${ARG_SETTINGS_FILE_NAME}")
    endif ()

    if (NOT EXISTS ${ARG_SETTINGS_FILE})
        message(FATAL_ERROR "Failed to find settings file ${ARG_SETTINGS_FILE} for target ${TARGET_NAME}")
    endif ()

    set_target_properties(${TARGET_NAME} PROPERTIES PORTAL_SETTINGS_PATH ${ARG_SETTINGS_FILE})

    portal_read_settings(${TARGET_NAME})
    get_target_property(DISPLAY_NAME ${TARGET_NAME} PORTAL_DISPLAY_NAME)

    if (APPLE AND ARG_MAKE_STANDALONE)
        set_target_properties(${TARGET_NAME} PROPERTIES
                MACOSX_BUNDLE TRUE
                MACOSX_BUNDLE_IDENTIFIER com.portal.${TARGET_NAME}
                MACOSX_BUNDLE_BUNDLE_NAME ${DISPLAY_NAME}
                MACOSX_BUNDLE_ICON_FILE ${BUNDLE_ICON_FILE}
                MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
                MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION}
        )
    endif ()

    portal_fetch_resources(${TARGET_NAME} portal::engine)
    portal_fetch_configs(${TARGET_NAME} portal::engine)

    portal_fetch_resources(${TARGET_NAME}_editor portal::engine)
    portal_fetch_configs(${TARGET_NAME}_editor portal::engine)

    foreach (RESOURCE_PATH ${ARG_RESOURCE_PATHS})
        portal_add_resources(${TARGET_NAME} ${ARG_RESOURCE_PATHS})
    endforeach ()

    if (NOT ARG_NO_CONFIG)
        portal_add_configs(${TARGET_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/config)
    endif ()

    portal_setup_compile_configs(${TARGET_NAME} ${ARG_SETTINGS_FILE_NAME} ${ICON_PNG_FILE})
    portal_setup_compile_configs(${TARGET_NAME}_editor ${ARG_SETTINGS_FILE_NAME} ${ICON_PNG_FILE})

    portal_install_game(${TARGET_NAME})

    portal_package_game(
            ${TARGET_NAME}
            ${DISPLAY_NAME}
            VENDOR ${ARG_VENDOR}
            CONTACT ${ARG_CONTACT}
    )
endfunction()

